{
  "source": "ArXiv",
  "filename": "012_Multi-Agent_Motion_Planning_For_Differential_Drive.pdf",
  "total_chars": 45212,
  "total_chunks": 70,
  "chunks": [
    {
      "id": 1,
      "content": "=== 페이지 1 ===\nMulti-Agent Motion Planning For Differential Drive Robots Through Stationary\nState Search\nJingtianYan,JiaoyangLi\nCarnegieMellonUniversity\njingtianyan@cmu.edu,jiaoyangli@cmu.edu\nAbstract\nMAPF(a)\nACT1 ACT2 ACT3\nMulti-Agent Motion Planning (MAMP) finds various ap-\nplications in fields such as traffic management, airport op- MAPF+ADG(b)\nACT2\nerations, and warehouse automation. In many of these en-\nACT1 ACT2 ACT3 ACT3\nvironments, differential drive robots are commonly used. These robots have a kinodynamic model that allows only SIPP-IP(c)\nB\nin-place rotation and movement along their current orienta-\nACT1 ACT2 ACT3\ntion, subject to speed and acceleration limits.",
      "size": 678,
      "sentences": 3
    },
    {
      "id": 2,
      "content": "ly used. These robots have a kinodynamic model that allows only SIPP-IP(c)\nB\nin-place rotation and movement along their current orienta-\nACT1 ACT2 ACT3\ntion, subject to speed and acceleration limits. However, ex- ACT1\nistingMulti-AgentPathFinding(MAPF)-basedmethodsof- ACT2 PSB(d) A\ntenusesimplifiedmodelsforrobotkinodynamics,whichlim- ACT1 ACT3\nitstheirpracticalityandrealism.Inthispaper,weintroduce\nathree-levelframeworkcalledMASStoaddressthesechal- ACT1 ACT2 ACT3 MASS(e)\nlenges.MASScombinesMAPF-basedmethodswithourpro-\nposedstationarystatesearchplannertogeneratehigh-quality\nkinodynamically-feasibleplans.WefurtherextendMASSus-\nFigure 1: Speed profile of agent A (blue line: linear veloc-\ning an adaptive window mechanism to address the lifelong\nity, red line: angular velocity) generated by (a) MAPF, (b)\nMAMPproblem.Empirically,wetestedourmethodsonthe\nsingle-shotgridmapdomainandthelifelongwarehousedo- MAPF+ADG, (c) SIPP-IP, (d) PSB, and (e) MASS.",
      "size": 954,
      "sentences": 3
    },
    {
      "id": 3,
      "content": "red line: angular velocity) generated by (a) MAPF, (b)\nMAMPproblem.Empirically,wetestedourmethodsonthe\nsingle-shotgridmapdomainandthelifelongwarehousedo- MAPF+ADG, (c) SIPP-IP, (d) PSB, and (e) MASS. Agent\nmain.Ourmethodshowsupto400%improvementsinterms A first moves upward (ACT1) while adjusting its speed to\nofthroughputcomparedtoexistingmethods. avoidcollisionswithagentB,performsanin-placerotation\n(ACT2),andthenmovestotheright(ACT3). 1 Introduction\nWestudytheMulti-AgentMotionPlanning(MAMP)prob- unrealisticforreal-worldexecution(seeFig.1(a)foranex-\nlem which aims to find collision-free kinodynamically fea- ample). To apply MAPF methods to MAMP, ADG (Ho¨nig\nsible paths for a team of agents in a fully observable en- et al. 2019) post-processes the speed profiles of the MAPF\nvironment while minimizing their arrival time.",
      "size": 829,
      "sentences": 6
    },
    {
      "id": 4,
      "content": "MAPF methods to MAMP, ADG (Ho¨nig\nsible paths for a team of agents in a fully observable en- et al. 2019) post-processes the speed profiles of the MAPF\nvironment while minimizing their arrival time. This prob- plantomeetkinodynamicconstraintswhilemaintainingthe\nlem finds various real-world applications, including traffic passingordersofagentsateachlocation.However,asshown\nmanagement (Ho et al. 2019), airport operations (Li et al. inFig.1(b),suchmethodscanleadtolongexecutiontime\n2019), and warehouse automation (Kou et al. 2019). Dif- as the initial MAPF plan (Fig. 1 (a)) overlooks kinody-\nferential drive robots are widely used in many of these en- namicconstraints.SIPP-IP(AliandYakovlev2023)extends\nvironments.",
      "size": 718,
      "sentences": 8
    },
    {
      "id": 5,
      "content": "et al. 2019). Dif- as the initial MAPF plan (Fig. 1 (a)) overlooks kinody-\nferential drive robots are widely used in many of these en- namicconstraints.SIPP-IP(AliandYakovlev2023)extends\nvironments. These robots, often navigating on a grid map, MAPFmethodstoMAMPbysearchingwithafixednumber\ncanmoveforwardalongtheirorientationwithboundedve- of predefined actions with discretized speeds and accelera-\nlocityandacceleration.Theycanonlychangetheirorienta- tions.However,asshowninFig.1(c),duetoitsdiscretized\ntionthroughin-placerotationwhenatzerospeed.Although nature,thelimitedactionchoicescanleadtolongexecution\nmuch work has been done to address the MAMP problem, time or even failures in solving certain cases. Moreover, to\nexistingmethodsofteneitherfailtoaccountfortheorienta- accountforthedifferentchoicesofspeedsandaccelerations,\ntionsofrobotsoroverlookcontinuousdynamicconstraints. SIPP-IPexploresahigh-dimensionalstatespacewhichcom-\npromises its efficiency.",
      "size": 962,
      "sentences": 7
    },
    {
      "id": 6,
      "content": "fortheorienta- accountforthedifferentchoicesofspeedsandaccelerations,\ntionsofrobotsoroverlookcontinuousdynamicconstraints. SIPP-IPexploresahigh-dimensionalstatespacewhichcom-\npromises its efficiency. The recent work PSB (Yan and Li\nMulti-Agent Path Finding (MAPF) (Stern et al. 2019)\n2024)avoidssuchdiscretizationbycombiningsearch-based\nmethodsareapromisingsolutionthatscalestohundredsof\nandoptimization-basedmethods,butitdoesnotconsiderthe\nagents.However,theyassumeinstantaneousmovementand\norientationsofagents,makingithardtoapplytodifferential\ninfinite acceleration capabilities, resulting in plans that are\ndriverobots,asshowninFig.1(d). Copyright©2025,AssociationfortheAdvancementofArtificial In this work, we introduce MAPF-SSIPP-SPS (MASS),\nIntelligence(www.aaai.org).Allrightsreserved.",
      "size": 792,
      "sentences": 5
    },
    {
      "id": 7,
      "content": "n plans that are\ndriverobots,asshowninFig.1(d). Copyright©2025,AssociationfortheAdvancementofArtificial In this work, we introduce MAPF-SSIPP-SPS (MASS),\nIntelligence(www.aaai.org).Allrightsreserved. aframeworktoaddresstheMAMPproblemfordifferential\n4202\nceD\n71\n]OR.sc[\n1v95331.2142:viXra\n[표 데이터 감지됨]\n\n=== 페이지 2 ===\ndriverobots.MASSusesakeyobservationthattheplanfor tween agents a and a is detected, the PT is expanded by\ni j\nthese robots always alternates between rotation and move- creatingtwochildnodes,eachwithanadditionalpriorityor-\nment. Thus, the state at the transition between two actions deringi≺jorj ≺i,indicatinga hashigherorlowerprior-\ni\n(finish a movement to start rotation or the reverse) is crit- itythana .Ineachchildnode,PBSusesalow-levelplanner\nj\nically important. Since those states must have zero speed, toreplanthepathsbasedontheupdatedpriorityorderings. we refer to them as stationary states.",
      "size": 914,
      "sentences": 6
    },
    {
      "id": 8,
      "content": "thana .Ineachchildnode,PBSusesalow-levelplanner\nj\nically important. Since those states must have zero speed, toreplanthepathsbasedontheupdatedpriorityorderings. we refer to them as stationary states. Instead of searching The search terminates when a PT node with collision-free\nat high-dimensional state space that models various speeds pathsisfound. ofrobots,wefocusoursearchonthesestationarystatesand\nMAMP Algorithms The first category of MAMP meth-\nactionsthatconnectthem.InMASS,weuseaMAPF-based\nodsdirectlyextendssingle-agentmotionplanners(Cˇa´petal.",
      "size": 554,
      "sentences": 5
    },
    {
      "id": 9,
      "content": "bots,wefocusoursearchonthesestationarystatesand\nMAMP Algorithms The first category of MAMP meth-\nactionsthatconnectthem.InMASS,weuseaMAPF-based\nodsdirectlyextendssingle-agentmotionplanners(Cˇa´petal. planneratLevel1toresolvecollisionsbetweenagents.This\n2013).Thesemethodscombinethestatespaceofindividual\nlevelimposestemporalconstraintsonLevel2andcallsitto\nagents into a collective joint space to perform single-agent\ngetaplanforeachagent.WeproposeStationarySafeInter-\nmotionplanning.Sincethedimensionofthisspaceincreases\nvalPathPlanning(SSIPP)atLevel2tosearchforasingle-\nexponentially in the number of agents, planning within the\nagentkinodynamicallyfeasibleplan.Comparedtostandard\njoint state space of agents presents scalability challenges. SIPP(PhillipsandLikhachev2011),SSIPPusesstationary\nAnother category of methods uses the MAPF methods to\nnodeexpansiontofindneighboringstationarystatesandthe\nsolvetheMAMPproblem.Someofthemusediscretepaths\nactions needed to reach them.",
      "size": 976,
      "sentences": 3
    },
    {
      "id": 10,
      "content": "PPusesstationary\nAnother category of methods uses the MAPF methods to\nnodeexpansiontofindneighboringstationarystatesandthe\nsolvetheMAMPproblem.Someofthemusediscretepaths\nactions needed to reach them. At Level 3, an optimization-\nfromMAPFplannerstogeneratetrajectoriesthatmeetkin-\nbased speed profile solver (SPS) is used to determine the\nodynamicconstraints(Ho¨nigetal.2016;Zhangetal.2021;\nspeedprofilesfortheseactions. Ho¨nig et al. 2019). For instance, the Action Dependency\nOur main contributions include: 1. We propose a frame-\nGraph (ADG) (Ho¨nig et al. 2019) generates speed pro-\nworkcalledMASS,athree-levelMAMPplannercapableof\nfiles for each agent based on discrete MAPF plans. It post-\nfinding collision-free plans for a large group of differential\nprocessesthespeedprofilesoftheMAPFplantomeetkino-\ndrive robots. 2.",
      "size": 823,
      "sentences": 9
    },
    {
      "id": 11,
      "content": "capableof\nfiles for each agent based on discrete MAPF plans. It post-\nfinding collision-free plans for a large group of differential\nprocessesthespeedprofilesoftheMAPFplantomeetkino-\ndrive robots. 2. We evaluate MASS on the standard MAPF\ndynamicconstraintswhilemaintainingthepassingordersof\nbenchmark, showing significant improvement in terms of\nagents at each location by encoding the action-precedence\nsuccess rate, especially for large-scale maps. 3. We extend\nrelationships. The solution quality of these methods highly\nMASStoaddressthelifelongMAMPproblemwhereagents\nreliesonthediscretepathsfromMAPFplanners.However,\nare assigned new goals after they reach their current ones. as discussed in (Varambally, Li, and Koenig 2022), since\nWeevaluateMASSinahigh-fidelityautomatedwarehouse\nthe MAPF planners use an inaccurate kinodynamic model,\nsimulator (shown in Fig. 7). MASS shows up to 400% im-\ntheir solution quality is often limited.",
      "size": 937,
      "sentences": 10
    },
    {
      "id": 12,
      "content": "WeevaluateMASSinahigh-fidelityautomatedwarehouse\nthe MAPF planners use an inaccurate kinodynamic model,\nsimulator (shown in Fig. 7). MASS shows up to 400% im-\ntheir solution quality is often limited. Some other meth-\nprovement in terms of solution cost compared to a MAPF\nodsextendMAPFmethodstoconsiderrobotkinodynamics\nplannerwithapost-processingframework. duringplanning.Thesemethodstypicallydiscretizetheac-\ntionspaceanduseagraph-search-basedmethod(Solisetal. 2 Background\n2021;Cohenetal.2019;AliandYakovlev2023).However,\nInthissection,webeginwithareviewofMAPFalgorithms. withtheirdiscretizednature,theyconsideralimitednumber\nAfterthat,wegothroughtherelatedworkinMAMP. ofactionsandthusfailtocapturethefullrangeofpossible\nactions that agents could exhibit. Moreover, they also face\nMAPF Algorithms MAPF methods have achieved re-\nscalability challenges as they search in a high-dimensional\nmarkable progress in finding discrete collision-free paths\nstate space.",
      "size": 962,
      "sentences": 9
    },
    {
      "id": 13,
      "content": "over, they also face\nMAPF Algorithms MAPF methods have achieved re-\nscalability challenges as they search in a high-dimensional\nmarkable progress in finding discrete collision-free paths\nstate space. To avoid such discretization, PSB (Yan and Li\nfor hundreds of agents. Most state-of-the-art MAPF meth-\n2024)combinessearch-basedandoptimization-basedmeth-\nods, such as Conflict-Based Search (CBS) (Sharon et al. ods to produce solutions with smooth speed profiles. How-\n2015; Andreychuk et al. 2022) and Priority-Based Search\never, PSB cannot handle the in-place rotation of agents,\n(PBS) (Ma et al. 2019), use a bi-level structure. At the\nmakingithardtoapplytodifferentialdriverobots.Theex-\nhighlevel,theyresolvecollisionsamongagentsbyintroduc-\nisting work closest to ours is the extended abstract by Kou\ning temporal obstacles into low-level single-agent solvers. etal.",
      "size": 870,
      "sentences": 9
    },
    {
      "id": 14,
      "content": "ldriverobots.Theex-\nhighlevel,theyresolvecollisionsamongagentsbyintroduc-\nisting work closest to ours is the extended abstract by Kou\ning temporal obstacles into low-level single-agent solvers. etal. (2019).Insteadofsearchingthehigh-dimensionalstate\nThese solvers then plan paths for individual agents trying\nspace,theysuggestperforminganA∗ searchoverthestates\nto avoid those temporal obstacles. In our experiments, we\nwithspeedsofzeroandshowpromisingpreliminaryresults. test MASS with two MAPF algorithms, PP and PBS. In\nOurMASSisinspiredbythisidea.",
      "size": 550,
      "sentences": 6
    },
    {
      "id": 15,
      "content": "thestates\nto avoid those temporal obstacles. In our experiments, we\nwithspeedsofzeroandshowpromisingpreliminaryresults. test MASS with two MAPF algorithms, PP and PBS. In\nOurMASSisinspiredbythisidea. Priority Planning (PP) (Erdmann and Lozano-Perez 1987),\nthe planner begins by assigning a total priority ordering to\n3 ProblemFormulation\nallagentsrequiringlower-priorityagentstoavoidcollisions\nwithhigher-priorityones.Then,thePPplanspathsforeach WedefineourMAMPproblemwithdifferential-driveagents\nagentfromhighprioritytolowpriority.Duringthisprocess, astheMAMP problemonanundirectedgraphG=(V,E)\nD\nagents treat the path from higher priority agents as tempo- andasetofM agentsR={a ,...,a }.Weadoptthegrid\n1 M\nralobstacles.Priority-BasedSearch(PBS)(Maetal.2019) model from the MAPF problem (Walker, Sturtevant, and\nR\nsearchesforagoodpriorityorderingthatpreventscollisions Felner 2018) and represent G as a four-neighbor grid map. among agents.",
      "size": 940,
      "sentences": 6
    },
    {
      "id": 16,
      "content": "PBS)(Maetal.2019) model from the MAPF problem (Walker, Sturtevant, and\nR\nsearchesforagoodpriorityorderingthatpreventscollisions Felner 2018) and represent G as a four-neighbor grid map. among agents. PBS explores a binary Priority Tree (PT) in Vertices in V represent grid cells in the map, with their lo-\na depth-first manner, where each PT node contains a set of cationsthesameasthecenterofeachcellandshapesequal\npartialpriorityorderingsandcorrespondingpaths.Theroot to the cell size. An edge (v ,v ) ∈ E corresponds to pos-\ni j\nnodestartswithnopriorityorderings.Whenacollisionbe- sible transitions between v and v .",
      "size": 618,
      "sentences": 4
    },
    {
      "id": 17,
      "content": "ialpriorityorderingsandcorrespondingpaths.Theroot to the cell size. An edge (v ,v ) ∈ E corresponds to pos-\ni j\nnodestartswithnopriorityorderings.Whenacollisionbe- sible transitions between v and v . We use a differential\ni j\n=== 페이지 3 ===\nMAPF-based SSIPP SPS\nPlanner\nBézierCurve Solver\nCandidate Paths Binary Acceleration Solver\nTime Time\n…\n(2,0) occupied\nform [3.0 6.0) Vertices Vertices\n(a) (b) (c)\n…\n(0,0) occupied from [5.0, INF) Time\nVertices\nFigure2:Systemoverview.In(b),thegreenstripsaresafeintervals,thedarkgreenstripsarestationarysafeintervals,andthe\ngrayboxesaretemporalobstaclesgivenbyLevel1. drive robot model with a specific shape.",
      "size": 646,
      "sentences": 4
    },
    {
      "id": 18,
      "content": "es\nFigure2:Systemoverview.In(b),thegreenstripsaresafeintervals,thedarkgreenstripsarestationarysafeintervals,andthe\ngrayboxesaretemporalobstaclesgivenbyLevel1. drive robot model with a specific shape. When at a vertex, the shape of v. A collision occurs if two agents occupy the\nanagentcanhaveadiscretizedorientationθ ∈Θ.Wedefine samevandatoverlappingtimeintervals.Weusearrivaltime\nthe state of an agent as a collection of its vertex, orienta- toindicatethetimeneededfora toreachv .Ourtaskis\nm gm\ntion,andspeedataspecifictime.Eachagenta initiatesits togenerateplansforallagentssothatnocollisionshappen\nm\nmovementfromaspecifiedstart(vertex)v ∈V andstart whileminimizingthesumoftheirarrivaltime.",
      "size": 692,
      "sentences": 3
    },
    {
      "id": 19,
      "content": "gm\ntion,andspeedataspecifictime.Eachagenta initiatesits togenerateplansforallagentssothatnocollisionshappen\nm\nmovementfromaspecifiedstart(vertex)v ∈V andstart whileminimizingthesumoftheirarrivaltime. sm\norientationθ ∈Θ,whereΘisafinitesetofpossibleorien-\ns\nLifelong MAMP Compared to the single-shot MAMP\ntations.Eachagenta hasasingledesignatedgoal(vertex) D\nm\nformulation, in the lifelong MAMP model, there are two\nv ∈V.Allagentsstartsimultaneouslyandremainattheir\ngm\nmain differences: (D1) Each agent receives new goals as-\nrespectivegoalsaftertheyfinish.Anagentcanperformone\nsigned by an external task assigner during execution and\nofthefollowingactionsateachvertexwiththeactiontime\nmustvisittheseassignedgoalssequentially. (D2)Agentsare\nT beingthetimeittakestofinishthisaction:\nm\nnotrequiredtostayattheirgoals,instead,theymustperform\nDefinition1.",
      "size": 848,
      "sentences": 3
    },
    {
      "id": 20,
      "content": "tionsateachvertexwiththeactiontime\nmustvisittheseassignedgoalssequentially. (D2)Agentsare\nT beingthetimeittakestofinishthisaction:\nm\nnotrequiredtostayattheirgoals,instead,theymustperform\nDefinition1. (Rotate)Arotate(θ ,θ )letsanagentchange\ni j one of the three additional actions at each goal, namely at-\nitsorientationfromθ ∈ Θtoθ ∈ Θonitscurrentvertex. i j taching themselves to a shelf, detaching themselves from a\nThisactionbeginsandendswiththeagentatzerospeedand\nshelf, or waiting at a station. Our task is to maximize the\nfollowsapredefinedangularvelocityprofile.Theactiontime\nthroughput(=averagenumberofreachedgoalverticesina\nofrotate(θ ,θ )isnogreaterthanthesumoftheactiontime\ni j certaintimeduration). ofrotate(θ ,θ )androtate(θ ,θ )forallθ . i k k j k\nDefinition2. (Move)Amove(v ,v )letsanagentmovefor- 4 MASS\ni j\nwardinitscurrentorientationfromv tov alongastraight\ni j In this section, we begin with a system overview of our\nline segment ϕ , which may include one or more vertices.",
      "size": 992,
      "sentences": 8
    },
    {
      "id": 21,
      "content": "letsanagentmovefor- 4 MASS\ni j\nwardinitscurrentorientationfromv tov alongastraight\ni j In this section, we begin with a system overview of our\nline segment ϕ , which may include one or more vertices. i,j proposed method, MASS, followed by the specifics of the\nThisactionbeginsandendswiththeagentatzerospeedand\nSSIPPusedinLevel2.Next,weintroduceapartialstation-\nfollowsaspeedprofileℓ (t|ϕ ),denotedasthedistance\ni,j i,j ary expansion mechanism to improve its scalability. Then,\ntraveled by an agent as a function of time t along a given\nwe present the formulation for speed profile optimization\nlinesegmentϕ .Foragenta ,thespeedprofileofitsmove\ni,j m andtwoexamplesolvers.Finally,wediscussthetechniques\nactionisconstrainedbythefollowingdynamicconstraints:\nusedtoextendMASStothelifelongMAMPscenario.",
      "size": 797,
      "sentences": 3
    },
    {
      "id": 22,
      "content": "segmentϕ .Foragenta ,thespeedprofileofitsmove\ni,j m andtwoexamplesolvers.Finally,wediscussthetechniques\nactionisconstrainedbythefollowingdynamicconstraints:\nusedtoextendMASStothelifelongMAMPscenario. dkℓ (t|ϕ )\nUk ≤ i,j i,j ≤Uk,∀k ∈{1,2} (1) 4.1 SystemOverview\nm dtk m\n(cid:12) MAPF-based Planner At Level 1, we borrow the MAPF-\ndℓ\ni,j\n(t|ϕ\ni,j\n)(cid:12)\n(cid:12) =U1, (2) based planner to resolve collisions between agents. Our\ndt (cid:12) t=0,Tm m frameworkiscompatiblewithanyMAPFsolveremploying\nabi-levelstructureasdiscussedinrelatedwork.Empirically,\nwhereUk andUk representthelowerandupperboundsof\nm m weusePPandPBSastheLevel-1planner.",
      "size": 639,
      "sentences": 3
    },
    {
      "id": 23,
      "content": "t=0,Tm m frameworkiscompatiblewithanyMAPFsolveremploying\nabi-levelstructureasdiscussedinrelatedwork.Empirically,\nwhereUk andUk representthelowerandupperboundsof\nm m weusePPandPBSastheLevel-1planner. speed(whenk =1)andacceleration(whenk =2),respec-\nStationary SIPP (SSIPP) The task of Level 2 is to find a\ntively,withtheminimumspeedbeingU1 = 0.Theplanner\nm plan for an agent with minimum arrival time while avoid-\nneeds todetermine aspeed profile (including T ) foreach\nm ingtemporalobstacles(e.g.,pathsofhigherpriorityagents\nmoveaction.Wedefineamoveactionasdynamicallyfeasi-\nfromPPorPBS)givenbyLevel1.AsshowninFig.2(b),\nbleifitsspeedprofilesatisfiestheseconstraints. wefirstbuildasafeintervaltableT basedonthosetempo-\nAtimedactionrepresentsanactionthatstartsataspecific ralobstacles.ThistableassociatedeachvertexofGwitha\ntime.",
      "size": 826,
      "sentences": 3
    },
    {
      "id": 24,
      "content": "sspeedprofilesatisfiestheseconstraints. wefirstbuildasafeintervaltableT basedonthosetempo-\nAtimedactionrepresentsanactionthatstartsataspecific ralobstacles.ThistableassociatedeachvertexofGwitha\ntime. A plan p of a is a set of timed actions that move set of safe intervals, which are time intervals not occupied\nm m\na fromitsstarttoitsgoal.Anagentreachesavertexiffthe bythetemporalobstacles.Then,Level2performsanSSIPP\nm\ngeometric centers of the vertex and the agent overlap. We searchonT tofindtheneighborstationarystatesalongwith\ndefinethatanagentoccupiesavertexvifitsshapeoverlaps theactionsthatleadtothem,wherethespeedprofileofthese\n=== 페이지 4 ===\nactionsisfoundbyLevel3.Weuseapartialstationaryex- Algorithm1:StationarySIPP(SSIPP)\npansion(PE)mechanismtofurtherimproveitsefficiency.",
      "size": 782,
      "sentences": 4
    },
    {
      "id": 25,
      "content": "heactionsthatleadtothem,wherethespeedprofileofthese\n=== 페이지 4 ===\nactionsisfoundbyLevel3.Weuseapartialstationaryex- Algorithm1:StationarySIPP(SSIPP)\npansion(PE)mechanismtofurtherimproveitsefficiency. Input:startvertexv ,startorientationθ ,goalvertexv ,\nSpeedProfileSolver(SPS)ThetaskofLevel3istofinda s s g\nsafeintervaltableT\nspeedprofilethattravelswithinsafeintervalsgivenbyLevel\n1 root n←(v s ,θ s ,none,∅,T[v s ][0])\n2,satisfiesdynamicconstraints,andachievesoptimalaction 2 pushToOPEN(root n)\ntime. We introduce two solvers in this section: the Binary 3 p*.arrival time←∞\nAccelerationSolver,anincompletebutfastmethod,andthe 4 whileOPEN̸=∅do\nBe´zier-CurveSolver,acompletebutslowmethod.",
      "size": 687,
      "sentences": 3
    },
    {
      "id": 26,
      "content": "root n)\ntime. We introduce two solvers in this section: the Binary 3 p*.arrival time←∞\nAccelerationSolver,anincompletebutfastmethod,andthe 4 whileOPEN̸=∅do\nBe´zier-CurveSolver,acompletebutslowmethod. 5 n←OPEN.pop()\n6 ifn.f ≥p*.arrival timethenreturnp∗\n4.2 StationarySIPP(SSIPP) 7 ifn.v=v g andn.ub=∞ then\n8 ifn.g<p*.arrival timethenp∗←getPlan(n)\nGiven a safe interval table T, the task of Level 2 is to find 9 continue\na collision-free plan for agent a while minimizing its ar-\nm 10 (partial)StationaryNodeExpansion(n)\nrivaltime.Inourproblem,agentsmoveincontinuoustime\nwithcontinuousdynamics,leadingtoaninfinitenumberof 11 return“Nosolutionfound”\npossible states at each vertex. To address this, Level 2 em- 12 FunctionstationNodeExpansion(n)\nploys SSIPP, which performs an A* search on T to avoid 13 ifn.a̸=rotatethen //rotateexpansion\ndirectly searching through such states.",
      "size": 876,
      "sentences": 4
    },
    {
      "id": 27,
      "content": ". To address this, Level 2 em- 12 FunctionstationNodeExpansion(n)\nploys SSIPP, which performs an A* search on T to avoid 13 ifn.a̸=rotatethen //rotateexpansion\ndirectly searching through such states. Compared to stan- 14 {n′ 0 ,...,n′ j }←rotateExpansion(n)\ndard SIPP (Phillips and Likhachev 2011), SSIPP uses sta- 15 pushToOPEN(n′ 0 ,...,n′ j )\ntionarynodeexpansiontofindstationarystatesanddynam- 16 ifn.a̸=move then //moveexpansion\nically feasible actions connecting them. In the rest of this 17\nS←getMoveIntervals(n)\nsection,weomitsubscriptmforsimplicity. 18\nfor[lb,ub)∈Sdo\n19 createNodeByMove(n,[lb,ub))\nSSIPPNode ThesearchnodeofSSIPPisdefinedasn =\n{v,θ,a,[lb,ub)}.v ∈ V andθ ∈ Θarethevertexandori- 20 FunctioncreateNodeByMove(n,[lb,ub))\nentationoftheagent.aisthepreviousactionthatleadsthe 21 (ϕ,S)←backTrack([n.lb,n.ub),[lb,ub))\nagenttonoden.",
      "size": 847,
      "sentences": 5
    },
    {
      "id": 28,
      "content": "sn =\n{v,θ,a,[lb,ub)}.v ∈ V andθ ∈ Θarethevertexandori- 20 FunctioncreateNodeByMove(n,[lb,ub))\nentationoftheagent.aisthepreviousactionthatleadsthe 21 (ϕ,S)←backTrack([n.lb,n.ub),[lb,ub))\nagenttonoden. [lb,ub)isastationarysafeinterval,aspe- 22 ℓ(t)←getSpeedProfile(ϕ,S)\ncificsafeintervalinwhichtheagentcanmaintainastation- 23 ifℓ(t)̸=nullthen\narystateatv.",
      "size": 353,
      "sentences": 2
    },
    {
      "id": 29,
      "content": "←backTrack([n.lb,n.ub),[lb,ub))\nagenttonoden. [lb,ub)isastationarysafeinterval,aspe- 22 ℓ(t)←getSpeedProfile(ϕ,S)\ncificsafeintervalinwhichtheagentcanmaintainastation- 23 ifℓ(t)̸=nullthen\narystateatv. 24 n′ ←(vertex([lb,ub)),n.θ,move,∅,\n[n.lb+actionTime(ℓ),ub))\nMain Algorithm Algorithm 1 shows the pseudo-code of 25\npushToOPEN(n′)\nSSIPP.Webeginbyinitializingtherootnodewithstartver-\ntex v , start orientation θ , and the first interval at v in T\ns s s\n[Line1].ThenwepushtherootnodetoanopenlistOPEN\n[Line2].Thearrivaltimeofthebestplanp∗ isinitiallyset Time Speed Rea S c p h e a e b d le Safe Interv S a p ls eed\ntoinfinity[Line3].Wedefinetheg-valueofanodenasits\n(c) Vertices Vertices Vertices\nlb-value,itsh-valueastheminimumtimetomovefromits\nTime Time Time\nvertextothegoal,anditsf-valueasthesumofitsg-andh- nub\nvalues,whichisalowerboundonthearrivaltimeofanyplan nlb (a) (b) Vertices Vertices Vertices Vertices\nthatgoesthroughn(i.e.stopsatnwithinitstimeinterval).",
      "size": 962,
      "sentences": 3
    },
    {
      "id": 30,
      "content": "tothegoal,anditsf-valueasthesumofitsg-andh- nub\nvalues,whichisalowerboundonthearrivaltimeofanyplan nlb (a) (b) Vertices Vertices Vertices Vertices\nthatgoesthroughn(i.e.stopsatnwithinitstimeinterval). (a) (b) (c)\nAteachiteration,weselectthenodenwiththesmallestf-\nvaluefromOPEN[Line5].Ifthef-valueofnisbiggerthan Figure3:Illustrationofthesafeintervalsearchprocess. thearrivaltimeofp∗,itindicatesthatp∗istheoptimalplan. Weterminatethesearch[Line6]andreturnp∗ [Line11].If\nn is at the goal with infinite n.ub, we check if its g-value fined rotation speed profiles (i.e., rotate 90◦, −90◦, and\nis smaller than the arrival time of p∗. If true, we update p∗ 180◦) to generate the neighbor nodes of a given node n =\nbybacktrackingallancestornodesofn[Line7-8].Ineither\n{v,θ,a,[lb,ub)}. Specifically, we create a new neighbor\ncase, we proceed to the next iteration.",
      "size": 854,
      "sentences": 6
    },
    {
      "id": 31,
      "content": "to generate the neighbor nodes of a given node n =\nbybacktrackingallancestornodesofn[Line7-8].Ineither\n{v,θ,a,[lb,ub)}. Specifically, we create a new neighbor\ncase, we proceed to the next iteration. For all other nodes, noden′ = {v,θ′,rotate,[lb′,ub)}foreachpossibleorien-\nweusestationarynodeexpansiontogeneratenewneighbor tationθ′ ∈ Θ,withlb′ beingthesumoflbandtherotation\nnodes and push them to OPEN [Line 10]. This search pro- time.n′isdiscardediflb′ ≥ub. ceedsuntiltheoptimalplanisfoundorOPENisempty. Move Expansion: During move expansion, we first find all\nStationaryNodeExpansion Ateachstationarystate,we safeintervalsinT atallverticesthatmaybereachedthrough\nlet the agent perform an action different from its previous amoveactionfromthecurrentnode,referredtoasreachable\naction; otherwise, two identical actions can be combined intervals.Then,foreachreachableinterval,wetreatitasa\ninto one.",
      "size": 896,
      "sentences": 6
    },
    {
      "id": 32,
      "content": "different from its previous amoveactionfromthecurrentnode,referredtoasreachable\naction; otherwise, two identical actions can be combined intervals.Then,foreachreachableinterval,wetreatitasa\ninto one. Accordingly, stationary node expansion includes stationarysafeintervalanduseLevel3tofindaspeedprofile\ntwotypes:moveexpansionandrotateexpansion.Rotateex- to reach it. If a speed profile is found, we generate a new\npansionfindsallneighbornodesreachablethroughrotation, SSIPPnodeforthissafeinterval. whilemoveexpansiondoesthesameformovement. Concretely, if node n is the root node or its previous ac-\nRotate Expansion: Since the orientation is discretized, dur- tion is a rotate action, we first call getMoveIntervals\ning rotation expansion, we apply all the possible prede- whichusesabreadth-firstsearchonsafeintervalsalongthe\n=== 페이지 5 ===\nAlgorithm2:PartialStationaryExpansion Theorem1(CompletenessandoptimalityofSSIPP).",
      "size": 920,
      "sentences": 5
    },
    {
      "id": 33,
      "content": "tation expansion, we apply all the possible prede- whichusesabreadth-firstsearchonsafeintervalsalongthe\n=== 페이지 5 ===\nAlgorithm2:PartialStationaryExpansion Theorem1(CompletenessandoptimalityofSSIPP). SSIPP\nis complete and returns the optimal solution if one exists\n1 FunctionpartialStationaryNodeExpansion(n) when Level 3 is complete and optimal. Please refer to the\n2 ifn.F =∅then //expandnodenforthefirsttime\nAppendixfordetailedproof. 3 ifn.a̸=rotatethen\n4 {n′ 0 ,...,n′ j }←rotationExpansion(n) 4.3 PartialStationaryExpansion(PE)\n5 pushToOPEN(n′ 0 ,...,n′ j )\nDuring move expansion, we need to find the speed pro-\n6 ifn.a̸=movethen\nfiles for all reachable safe intervals. This branching factor\n7 n.F ←getMoveIntervals(n)\n8 Sortintervalsinn.F bytheirp-values can be very high, especially in large maps. To tackle this,\nwe use a partial stationary expansion mechanism extended\n9 ifn.F ̸=∅then //generateonechildnode from(Goldenbergetal.2014).",
      "size": 943,
      "sentences": 6
    },
    {
      "id": 34,
      "content": "bytheirp-values can be very high, especially in large maps. To tackle this,\nwe use a partial stationary expansion mechanism extended\n9 ifn.F ̸=∅then //generateonechildnode from(Goldenbergetal.2014). 10 createNodeByMove(n,n.F.pop())\nPE Node This node extends the SSIPP node by n =\n11 ifn.F ̸=∅then //reinsertnoden {v,θ,a,F,[lb,ub)}, where Reachable interval list F is a\n12 n.h←n.F.top().p−n.g\nlistthatcontainsallthereachablesafeintervals,denotedas\n13 pushToOPEN(n)\n{[lb ,ub ),...}. The intervals in F are sorted in ascending\n0 0\norderoftheirp-value(=lbplush-valueatitsassociatedver-\ntex), which is an underestimate of the arrival time through\nthisinterval. node’s orientation to find all reachable intervals [Lines 16\nand 17]. We use an example in Fig. 3 to illustrate this pro- PartialStationaryNodeExpansion Inpartialstationary\ncess.Webeginbyinitializingtherootintervalusingthein- nodeexpansion,insteadoffindingthespeedprofilesforall\nterval of the current node and push it to a queue.",
      "size": 985,
      "sentences": 7
    },
    {
      "id": 35,
      "content": "tationaryNodeExpansion Inpartialstationary\ncess.Webeginbyinitializingtherootintervalusingthein- nodeexpansion,insteadoffindingthespeedprofilesforall\nterval of the current node and push it to a queue. During reachableintervalsatonce,weonlygeneratethenodebased\neach iteration, we pop an interval from the queue and ex- on the reachable interval that is most promising. As shown\npand it by assuming the agent moves one vertex forward. in Algorithm 2, if n.F is empty and its previous action is\nIn our case, we first expand the interval at v denoted as move,wedorotateexpansiontoretrieveitsneighbornodes\n0\n[lb ,ub ).Astheagentmovesfromv tov ,anewinterval [Line 4-5].",
      "size": 662,
      "sentences": 4
    },
    {
      "id": 36,
      "content": "and its previous action is\nIn our case, we first expand the interval at v denoted as move,wedorotateexpansiontoretrieveitsneighbornodes\n0\n[lb ,ub ).Astheagentmovesfromv tov ,anewinterval [Line 4-5]. Otherwise, instead of performing move expan-\n0 0 0 1\n[lb +t ,∞)isgeneratedatv ,wheret isthemini- sion, we only retrieve all the reachable intervals for n.F\n0 min 1 min\nmumtimerequiredforthismovement.Following(Yanand [Line7].Incasen.F isnotempty,wepopthereachablein-\nLi2024),sincedynamicconstraintsareconsideredinLevel tervalwiththesmallestp-valueinn.F andgenerateaneigh-\n3, we can use relaxed dynamic constraints to expedite this bornodebasedonit[Line10].Finally,ifn.F remainsnon-\nexpansion process without compromising the guarantee of empty,weupdatetheheuristicvalueofnusingthesmallest\ncompleteness.Specifically,weestimatet asthetimethe p-valueinn.F andreinsertnintoOPEN[Line12-13].",
      "size": 883,
      "sentences": 2
    },
    {
      "id": 37,
      "content": "nsion process without compromising the guarantee of empty,weupdatetheheuristicvalueofnusingthesmallest\ncompleteness.Specifically,weestimatet asthetimethe p-valueinn.F andreinsertnintoOPEN[Line12-13]. min\nagenttakestomoveatmaximumspeed.Forsafeintervalsat Theorem 2 (Completeness and optimality of SSIPP with\nv 1 with a lower bound smaller than ub 0 , which are the in- PE). The partial expansion mechanism preserves the com-\ntervalsthatcanbedirectlyreachedfrom[lb 0 ,ub 0 ),wetreat pletenessandoptimalityofSSIPP.Detailedproofisprovided\ntheir overlap with [lb 0 +t min ,∞) as stationary safe inter- intheAppendix. vals. We get the safe intervals shown in Fig. 3 (a) in our\nexampleandpushittoareachableintervalsetS.Inthenext 4.4 SpeedProfileSolver(SPS)\niteration,wecontinuetoexpandthesafeintervalsatv .This\n1 Giventhelinesegmentϕ andsafeintervalsS fromLevel\ni,j\nsearchprocessproceedsrecursivelyuntilnostationarysafe\n2, SPS aims to find a speed profile ℓ (t) with the shortest\ni,j\nintervalscanbefound.",
      "size": 997,
      "sentences": 6
    },
    {
      "id": 38,
      "content": ".This\n1 Giventhelinesegmentϕ andsafeintervalsS fromLevel\ni,j\nsearchprocessproceedsrecursivelyuntilnostationarysafe\n2, SPS aims to find a speed profile ℓ (t) with the shortest\ni,j\nintervalscanbefound. actiontimethatsatisfiesboththedynamicconstraintsshown\nFor each reachable interval [lb,ub) ∈ S, we inEqs. (1)and(2)andtemporalconstraintsintroducedbyS\ncall createNodeByMove to generate an SSIPP node (i.e., the agent remains within the safe interval while pass-\n[Line 19]. We backtrack to get all safe intervals S = ingavertex).ThissectionintroducestwoSPSasexamples. {[lb 0 ,ub 0 ),...,[lb,ub)} along with its associated line seg- Notably, MASS is adaptable to other solvers, as long as it\nmentϕ[Line21].Then,wecallLevel3tofindaspeedpro-\nmeetsthespecifiedconstraints. fileℓ(t)basedonthem[Line22].Usingℓ(t)foundbyLevel\n3,wegenerateanewnodeattheassociatedvertexof[lb,ub) Binary Acceleration Solver (BAS) We adopt BAS\nandpushittoOPEN[Line24-25]. from (Kou et al. 2019).",
      "size": 964,
      "sentences": 8
    },
    {
      "id": 39,
      "content": "fileℓ(t)basedonthem[Line22].Usingℓ(t)foundbyLevel\n3,wegenerateanewnodeattheassociatedvertexof[lb,ub) Binary Acceleration Solver (BAS) We adopt BAS\nandpushittoOPEN[Line24-25]. from (Kou et al. 2019). This solver assumes that the agent\nbegins by waiting at the first vertex v of the line segment\ni\nDuplicateDetection Aduplicatedetectionmechanismis ϕ for a duration of t .",
      "size": 369,
      "sentences": 4
    },
    {
      "id": 40,
      "content": "25]. from (Kou et al. 2019). This solver assumes that the agent\nbegins by waiting at the first vertex v of the line segment\ni\nDuplicateDetection Aduplicatedetectionmechanismis ϕ for a duration of t . Then, it moves with its maxi-\ni,j wait\nusedtoeliminateredundantnodesduringthesearch.Before mumaccelerationuntilreachingitsmaximumspeed,moves\ninserting a node n into the open list, we check whether a atthisspeedforadurationoft ,andfinallydecelerates\nmove\nnodewiththesamevertex,orientation,andupperboundal- withitsmaximumdecelerationtostopatv .However,when\nj\nreadyexistsintheopenlistorhasbeenvisited.Ifaduplicate thelengthofϕ issmall,thespeedprofileformsatriangle\ni,j\nnoden′isfound,wecomparethelowerboundsofnandn′, shape, where the agent accelerates to a lower peak speed\nandretainthenodewiththesmallerlowerbound.Weprove and then decelerates to stop at v .",
      "size": 854,
      "sentences": 5
    },
    {
      "id": 41,
      "content": "iangle\ni,j\nnoden′isfound,wecomparethelowerboundsofnandn′, shape, where the agent accelerates to a lower peak speed\nandretainthenodewiththesmallerlowerbound.Weprove and then decelerates to stop at v . t can be computed\nj move\nthat this duplicate detection mechanism does not affect the basedonthelengthofϕ .Ourtaskistogetthet that\ni,j wait\ncompletenessortheoptimalityofMASS. minimizes action time while ensuring that ℓ (t) satisfies\ni,j\n=== 페이지 6 ===\nAlgorithm3:PseudocodeforWindowed-SSIPP 1 2 3 4 5 6 7 8 9\nInput:earlieststarttimet e ,goallistGandsafeinterval A\ntableT\n1 root n←(v s ,θ s ,none,∅,g=G[0],[t e ,T[v s ][0].ub)) B 1 2 2 1\n2 pushToOPEN(root n)\n3 n∗.f win ←∞ C\n4 whileOPEN̸=∅do\n5 n←OPEN.pop()\n6 ifn.f win >n∗.f win then getPlan(n∗) Figure 4: Limitation of directly applying RHCR to MASS.",
      "size": 798,
      "sentences": 3
    },
    {
      "id": 42,
      "content": "[0],[t e ,T[v s ][0].ub)) B 1 2 2 1\n2 pushToOPEN(root n)\n3 n∗.f win ←∞ C\n4 whileOPEN̸=∅do\n5 n←OPEN.pop()\n6 ifn.f win >n∗.f win then getPlan(n∗) Figure 4: Limitation of directly applying RHCR to MASS. 7 ifn.t ub =∞andn∗.f win >n.f win then n∗ ←n Solid circles are the current locations of agents and dashed\n8 ifn.v=n.gandn.lb+actionTime(G[n.l].a)<n.ub circlesaretheexpectedstartlocationforthenextepisode. then\n9 n′ ←(n.v,n.θ,n.g.a,∅,G.next(g),\n[n.lb+actionTime(G[n.l].a),n.ub)) ning window. We define actions that start before and finish\n10\npushToOPEN(n′)\naftertast-crossingactions.Withineachepisode,theadap-\n11 ifn.t lb <t w then tive window plan of each agent consists of the t w -crossing\n12 partialStationaryNodeExpansion(n) action, along with any preceding actions. During planning,\nweensurethatadaptivewindowplansarecollision-freebe-\n13 return“Nosolutionfound” tween agents.",
      "size": 879,
      "sentences": 5
    },
    {
      "id": 43,
      "content": "-crossing\n12 partialStationaryNodeExpansion(n) action, along with any preceding actions. During planning,\nweensurethatadaptivewindowplansarecollision-freebe-\n13 return“Nosolutionfound” tween agents. Since adaptive window plans can have arbi-\ntrary window sizes, the earliest start time for each agent at\nthenextepisodemayvary.Asagentsmustcompleteongo-\nthetemporalconstraintsintroducedbyS.Thisproblemcan ing actions, for each agent, we determine its start location\nbe formulated as a Linear Programming (LP) problem. We and its earliest start time for the next episode based on the\nborrow Fig. 2 (c) as a counterexample to show BAS is in- finalvertexandthecompletiontimeofitst -crossingaction\nh\ncomplete.Inthiscase,avalidspeedprofileexistswherethe fromthecurrentepisode.However,asshowninFig.4,this\nagent waits at v . However, BAS fails to find this solution approach introduces a new issue: Consider agents a and\n1 1\nbecauseitonlydeceleratesuponreachingthegoal.",
      "size": 960,
      "sentences": 6
    },
    {
      "id": 44,
      "content": "episode.However,asshowninFig.4,this\nagent waits at v . However, BAS fails to find this solution approach introduces a new issue: Consider agents a and\n1 1\nbecauseitonlydeceleratesuponreachingthegoal. a , where both their adaptive window plans at the current\n2\nepisode consist only of a t -crossing action (shown as the\nw\nBe´zier-curve Solver (BCS) We borrow BCS from (Yan\nblueandyellowarrowsinFig.4).Weassumetheyarealso\nand Li 2024). BCS models the speed profile using a scaled\nt -crossing actions. These plans are initially collision-free\nh\nBe´zier curve, which can approximate any continuous func-\nbecausethet -crossingactionofa occupiesB6onlyuntil\nw 2\ntion within its feasible range with sufficient control points. it completes.",
      "size": 731,
      "sentences": 6
    },
    {
      "id": 45,
      "content": "on-free\nh\nBe´zier curve, which can approximate any continuous func-\nbecausethet -crossingactionofa occupiesB6onlyuntil\nw 2\ntion within its feasible range with sufficient control points. it completes. However, in the next episode, when a starts\n2\nBCSencodesthetemporalanddynamicconstraintsasanLP\nfromB6,nofeasibleplanexiststoavoidacollision.Tore-\nproblem and then uses binary search to determine the opti-\nsolvethis,wealwaysappendawaitingactionattheendof\nmalactiontimebysolvingthisLPproblemrecursively.As\neachplan.Inthiscase,usingthesameexample,theadaptive\nshowninthepaper,givenanyϵ,BCPcanfindaspeedpro-\nwindowplanofa willcollidewitha . 1 2\nfileϵ-closetotheoptimalsolutionwithasufficientnumber\nThe windowed mechanism, which aims to find the node\nofcontrolpointsifoneexistsandreturnsfailureotherwise.",
      "size": 798,
      "sentences": 4
    },
    {
      "id": 46,
      "content": "ro-\nwindowplanofa willcollidewitha . 1 2\nfileϵ-closetotheoptimalsolutionwithasufficientnumber\nThe windowed mechanism, which aims to find the node\nofcontrolpointsifoneexistsandreturnsfailureotherwise. with the minimum f-value, introduces another issue: when\nusingthestandardf-value,agentsmayprefertowaitwithin\n4.5 LifelongMAMP\nD t ratherthanmoveforward.Forexample,whena inFig.4\nw 1\nIn this section, we extend MASS to address the lifelong movesfromB2toB8usinganunderestimatedheuristic,the\nMAMP problem. Many works have been done to extend f-valueatB2couldbesmallerthanitsneighbors,causingit\nD\nthe single-shot MAPF problem to the lifelong scenario. In towaitatB2.Toaddressthis,weintroducethef -value,\nwin\nthis work, we adapt the state-of-the-art method Rolling- defined as n.f = max(t ,n.g) + n.h. This penalizes\nwin w\nHorizon Collision Resolution (RHCR) (Li et al. 2021) to agentsforstoppingprematurelybeforet .",
      "size": 909,
      "sentences": 7
    },
    {
      "id": 47,
      "content": "k, we adapt the state-of-the-art method Rolling- defined as n.f = max(t ,n.g) + n.h. This penalizes\nwin w\nHorizon Collision Resolution (RHCR) (Li et al. 2021) to agentsforstoppingprematurelybeforet . w\nMASS.RHCRdecomposesthelifelongMAPFprobleminto\nMain Method In every episode, for each agent a , we\na sequence of windowed MAPF instances. Specifically, it m\nfirstupdatethestartlocationv ,theearlieststarttimet ,\nplanscollision-freepathsfort w timestepsandreplanspaths andgoallistG.Here,thegoal s l m iststoresthegoalvertices em in\nonceeveryt timesteps(t ≥ t ).However,inMASS,the\nh w h theordertheyshouldbevisited.Then,wecallMASStofind\nactions can have arbitrary action time. As a result, we can\ntheplansforthisepisode.Here,Level1andLevel3canbe\nnolongerdetermineafixedreplanningwindowsizet that\nw applied without any modification.",
      "size": 829,
      "sentences": 6
    },
    {
      "id": 48,
      "content": "find\nactions can have arbitrary action time. As a result, we can\ntheplansforthisepisode.Here,Level1andLevel3canbe\nnolongerdetermineafixedreplanningwindowsizet that\nw applied without any modification. As shown Algorithm 3,\nguarantees that all agents have just completed their actions\nwe begin the search process of Level 2 by initializing the\nand arrived at vertices at time t . In this work, we incor-\nw root node with the first goal in G and pushing it to OPEN\nporate an adaptive window mechanism that apply different\n[Line 1-2]. During each iteration, we find the node n with\nwindowsizesfordifferentagents. thesmallestf -valueandremoveitfromOPEN[Line5]. win\nAdaptive Window Similar to RHCR, we trigger replan- If the f -value of n is larger than the f -value of the\nwin win\nning every t time duration to plan for the next episode.",
      "size": 832,
      "sentences": 7
    },
    {
      "id": 49,
      "content": "moveitfromOPEN[Line5]. win\nAdaptive Window Similar to RHCR, we trigger replan- If the f -value of n is larger than the f -value of the\nwin win\nning every t time duration to plan for the next episode. optimal node n∗ found so far, we terminate the search and\nh\nHowever,sinceplanningforafixedepisodelengtht isnot backtracktoreturntheplan[Line6].Otherwise,incasen.ub\nw\nfeasible,t servesonlyastheminimumsizeofthereplan- isinfiniteandnhasasmallerf -valuethann∗,weupdate\nw win\n[표 데이터 감지됨]\n\n=== 페이지 7 ===\nFigure5:Successrateandaverageruntimeacrossallmaps.Thesuccessrateistheratioofsolvedinstancestoallinstances. 5 EmpiricalEvaluation\nWe implemented both our and baseline methods in C++. WeconductedallexperimentsonanUbuntu20.04machine\nequipped with an AMD 3990x processor and 188 GB of\nmemory. Our code was executed using a single core for all\ncomputations. The source code for our method is publicly\naccessibleathttps://github.com/JingtianYan/MASS-AAAI.",
      "size": 947,
      "sentences": 7
    },
    {
      "id": 50,
      "content": "3990x processor and 188 GB of\nmemory. Our code was executed using a single core for all\ncomputations. The source code for our method is publicly\naccessibleathttps://github.com/JingtianYan/MASS-AAAI. 5.1 Single-ShotMAMP\nD\nIn this experiment, we use PBS as Level 1 and both BAS\n(a) (b) and BCS as Level 3 . We denote the resulting two vari-\nants as MASS(BAS) and MASS(BCS). They are further\nFigure 6: Relative SoC is the ratio of the total arrival time\ncombined with the partial expansion mechanism, denoted\ntothesumofindividualagentarrivaltimeswithoutconsid-\nas MASS(BAS) w/ PE and MASS(BCS) w/ PE. We com-\nering collisions. We use points at 2.0 to indicate unsolved\npare these methods with a straightforward extension of\ninstances.Figure(a)showstherelativeSoCofSIPP-IPcom-\nSIPP-IP (Ali and Yakovlev 2023). SIPP-IP is a state-of-\nparedtoMASS(bothBASandBCS).Figure(b)showsthe\nthe-art single-agent safe interval path planner designed to\nrelativeSoCbetweenMASS(BAS)andMASS(BCS).",
      "size": 974,
      "sentences": 9
    },
    {
      "id": 51,
      "content": "PP-IP (Ali and Yakovlev 2023). SIPP-IP is a state-of-\nparedtoMASS(bothBASandBCS).Figure(b)showsthe\nthe-art single-agent safe interval path planner designed to\nrelativeSoCbetweenMASS(BAS)andMASS(BCS). accommodatekinodynamicconstraintsandtemporalobsta-\ncles,makingitasuitablerepresentationofmotion-primitive-\nbasedmethods.ToadaptSIPP-IPformulti-agentscenarios,\nn∗usingn[Line7].Ifn.vequalsthegoalvertexn.gthatn\nwereplacedLevel2andLevel3inMASSwiththeSIPP-IP. istryingtoreach,wegenerateanewnoden′ thatperforms\nthe required action n.g.a at vertex n.g and set its goal us- Simulation Setup We evaluated all methods on four-\ning the next element in G [Lines 9 and 10]. Finally, if the neighbor grid maps, including empty (empty-32-32,\nlowerboundofnissmallerthant ,wedopartialstationary size: 32×32), random (random-32-32-10, size: 32×32),\nw\nexpansion [Line 12].",
      "size": 853,
      "sentences": 5
    },
    {
      "id": 52,
      "content": "d 10]. Finally, if the neighbor grid maps, including empty (empty-32-32,\nlowerboundofnissmallerthant ,wedopartialstationary size: 32×32), random (random-32-32-10, size: 32×32),\nw\nexpansion [Line 12]. If MASS is unable to find a solution room (room-64-64-8, size: 64×64), den520d (den520d,\nwithinthegivencutofftime,wereusetheadaptivewindow size: 256×257), Boston (Boston 0 256, size: 256×256),\nplanfromthepreviousepisodeandcontinueitsexecution. warehouse-small (warehouse-10-20-10-2-1, size:\n[표 데이터 감지됨]\n\n=== 페이지 8 ===\nRuntime(s) MASS(BCS)w/PE MASS(BAS)w/PE\nstnegA01 Total 34.17±24.3% 0.17±0.4%\nPBS 0.00±0.0% 0.03±0.0%\nSIPP 0.02±0.0% 0.13±0.3%\nSPS 34.16±24.3% 0.01±0.0%\nstnegA051\nFigure 7: Simulation setup. (a) contains 8 stations, 600\nTotal nan 170.50±114.3% shelves, and 50 agents (based on the iRobot Create 2). (b)\nPBS nan 20.49±18.0% contains6stations,80shelves,and22agents.",
      "size": 879,
      "sentences": 6
    },
    {
      "id": 53,
      "content": "igure 7: Simulation setup. (a) contains 8 stations, 600\nTotal nan 170.50±114.3% shelves, and 50 agents (based on the iRobot Create 2). (b)\nPBS nan 20.49±18.0% contains6stations,80shelves,and22agents. SIPP nan 131.12±88.2%\nSPS nan 18.88±13.5%\nEnv t MASS(BAS) MASS(BCS) PPw/ADG\nw\nTable 1: Runtime breakdown of MASS on the\nwarehouse-small map in seconds. PBS, SIPP,\nandSPSaretheruntimeofeachcomponent. 161×63), warehouse-large (warehouse-20-40-10-2-\n2, size: 340×164) from the MovingAI benchmark (Stern\net al. 2019), and the sortation-center map (size:\n500 × 140) from the LMAPF Competition (Chan et al. 2024). For each map, we conducted experiments with\na progressive increment in the number of agents, using\nthe 25 “random scenarios” from the benchmark set. The\nagents were modeled as cycles with a diameter equal to\nthe length of the grid cell.",
      "size": 844,
      "sentences": 10
    },
    {
      "id": 54,
      "content": "s with\na progressive increment in the number of agents, using\nthe 25 “random scenarios” from the benchmark set. The\nagents were modeled as cycles with a diameter equal to\nthe length of the grid cell. All agents adhered to the same\nkinodynamicconstraints,wherethespeedisboundedbythe\nrange of [0,2] cell/s, while the acceleration is confined to\n[−0.5,0.5]cell/s2. Comparison AsshowninFig.5,PEimprovesthesuccess\nrate for MASS(BCS) on all maps. For MASS(BAS), it im-\nprovesthesuccessrateinlarge-scalemaps,whilemaintain-\ning comparableresults on small-scalemaps. This improve-\nmentisprimarilybecausePEshowsadvantageswhenLevel\n3istime-consuming(e.g.,usingBCS)orthebranchingfac-\ntor during move expansion is high (e.g., on large maps). ComparedtoBCS,BASdemonstratesitsadvantageinterms\nofsuccessrate.AsshowninFig.6(b),despiteBCSbeinga\ncompleteandoptimalmethod,BASachievesasimilarsolu-\ntion cost.",
      "size": 887,
      "sentences": 7
    },
    {
      "id": 55,
      "content": "expansion is high (e.g., on large maps). ComparedtoBCS,BASdemonstratesitsadvantageinterms\nofsuccessrate.AsshowninFig.6(b),despiteBCSbeinga\ncompleteandoptimalmethod,BASachievesasimilarsolu-\ntion cost. We hypothesize this is due to the scalability lim-\nitations of BCS, as it can only handle less congested cases\nwhere BAS also provides near-optimal solutions. SIPP-IP\nhasalowsuccessrateinobstacle-richmapsduetoitslim-\nitedactionchoice.Atthesametime,asshowninFig.6(a),\nitshowsworsesolutionqualitythanMASSincertaincases. Runtime As shown in Table 1, we include the\nruntime details of MASS with different SPS on\nwarehouse-10-20-10-2-1map.Theprimaryruntime\nbottleneck for MASS(BAS) lies in Level 2 (SIPP) for both\nthe10-agentand150-agentcases.Incontrast,MASS(BCS)\nis limited by Level 3 (SPS) in 10-agent scenarios and fails\ntoscaletoscenarioswithalargernumberofagents.",
      "size": 863,
      "sentences": 5
    },
    {
      "id": 56,
      "content": "or MASS(BAS) lies in Level 2 (SIPP) for both\nthe10-agentand150-agentcases.Incontrast,MASS(BCS)\nis limited by Level 3 (SPS) in 10-agent scenarios and fails\ntoscaletoscenarioswithalargernumberofagents. 5.2 LifelongMAMP\nD\nInthisexperiment,weusePPwithrandomstartasLevel1\nforMASS(BAS)andMASS(BCS),incorporatingthepartial\nexpansionmechanism.WeusePPw/ADG(Varambally,Li,\nandKoenig2022)torepresentmethodsthatcombineMAPF\nwitharobustexecutionframework.PPw/ADGusesRHCR\nesrapS\n20s 0.262±2.9% 0.215±6.4% 0.142±8.4%\n25s 0.264±4.3% 0.215±7.0% 0.152±8.3%\n30s 0.259±4.5% 0.215±1.9% 0.149±6.8%\n40s 0.259±3.0% 0.218±3.7% 0.148±7.1%\ntsegnoC\n20s 0.373±1.4% 0.294±4.4% 0.065±2.5%\n25s 0.380±3.4% 0.300±3.4% 0.075±4.0%\n30s 0.371±4.1% 0.294±13.4% 0.090±3.4%\n40s 0.372±6.7% 0.300±6.4% 0.095±2.4%\nTable2:ThroughputinCongestandSparse. to decompose the lifelong MAPF problem into windowed\nMAPF instances, uses PP with SIPP for planning in each\nwindow,andusesADGtoexecutetheplans.",
      "size": 949,
      "sentences": 3
    },
    {
      "id": 57,
      "content": "00±6.4% 0.095±2.4%\nTable2:ThroughputinCongestandSparse. to decompose the lifelong MAPF problem into windowed\nMAPF instances, uses PP with SIPP for planning in each\nwindow,andusesADGtoexecutetheplans. Simulation Setup We borrow the simulation setup\nfrom (Ho¨nig et al. 2019) to simulate a Kiva warehouse on\nthe Congest map with 50 agents and Sparse map with 22\nagents,usingAmazon’sHARMONIESsimulator,asshown\ninFig.7.Eachagenthasaspeedlimitfrom[0,2] m/sand\nan acceleration limit from [−0.5,0.5] m/s. We run each\nmethod for 1,000 simulation time seconds and average the\nresultsover7runs. Comparison We evaluate solution quality using the\nthroughput (=averagegoalsreachedpersecond).Asshown\ninTable2,thethroughputofMASS(BAS)andMASS(BCS)\nare significantly better than PP w/ ADG. This indicates\nthat incorporating the kinodynamics of agents during the\nplanning process can improve the solution quality. At the\nsame time, MASS(BAS) achieved a slight improvement in\nthroughput compared to MASS(BCS).",
      "size": 990,
      "sentences": 8
    },
    {
      "id": 58,
      "content": "t incorporating the kinodynamics of agents during the\nplanning process can improve the solution quality. At the\nsame time, MASS(BAS) achieved a slight improvement in\nthroughput compared to MASS(BCS). This is attributed to\nthefactorthatBASisabletoexploremorepriorityorderings\nwithinthegiventimewindowduetoitsshorterruntime. 6 Conclusion\nThispaperintroducesMASS,athree-levelmulti-agentmo-\ntion planning framework designed to tackle the MAMP\nproblem for differential drive robots. MASS uses SSIPP to\nsearchthestationarystatealongwithactionsbetweenthem. We further add a partial stationary expansion mechanism\nto improve its scalability and extend MASS to the lifelong\nMAMP domain.Empirically,MASSshowssignificantim-\nD\nprovements in both scalability and solution quality com-\nparedtoexistingmethods. [표 데이터 감지됨]\n\n=== 페이지 9 ===\nAcknowledgments Li,J.;Gong,M.;Liang,Z.;Liu,W.;Tong,Z.;Yi,L. ;Morris,\nR.;Pasearanu,C.;andKoenig,S.2019.",
      "size": 925,
      "sentences": 9
    },
    {
      "id": 59,
      "content": "in both scalability and solution quality com-\nparedtoexistingmethods. [표 데이터 감지됨]\n\n=== 페이지 9 ===\nAcknowledgments Li,J.;Gong,M.;Liang,Z.;Liu,W.;Tong,Z.;Yi,L. ;Morris,\nR.;Pasearanu,C.;andKoenig,S.2019. Departureschedul-\nThe research wassupported by the National Science Foun-\ning and taxiway path planning under uncertainty. In Pro-\ndation(NSF)undergrantnumber#2328671andagiftfrom\nceedingsoftheAIAAAviationForum,2930–2937. Amazon.Theviewsandconclusionscontainedinthisdoc-\numentarethoseoftheauthorsandshouldnotbeinterpreted Li,J.;Tinka,A.;Kiesel,S.;Durham,J.W.;Kumar,T.S. ;and\nasrepresentingtheofficialpolicies,eitherexpressedorim- Koenig,S.2021. Lifelongmulti-agentpathfindinginlarge-\nplied,ofthesponsoringorganizations,agencies,ortheU.S. scale warehouses. In Proceedings of the AAAI Conference\ngovernment. onArtificialIntelligence,volume35,11272–11281. Ma, H.; Harabor, D.; Stuckey, P. J.; Li, J.; and Koenig, S.\nReferences 2019.",
      "size": 928,
      "sentences": 12
    },
    {
      "id": 60,
      "content": "theU.S. scale warehouses. In Proceedings of the AAAI Conference\ngovernment. onArtificialIntelligence,volume35,11272–11281. Ma, H.; Harabor, D.; Stuckey, P. J.; Li, J.; and Koenig, S.\nReferences 2019. Searching with consistent prioritization for multi-\nAli,Z.A.;andYakovlev,K.2023. SafeIntervalPathPlan- agent path finding. In Proceedings of the AAAI conference\nning with Kinodynamic Constraints. In Proceedings of onartificialintelligence,volume33,7643–7650. the AAAI Conference on Artificial Intelligence, volume 37, Phillips, M.; and Likhachev, M. 2011. SIPP: Safe interval\n12330–12337. path planning for dynamic environments. In Proceedings\nof the IEEE International Conference on Robotics and Au-\nAndreychuk,A.;Yakovlev,K.;Surynek,P.;Atzmon,D. ;and\nStern, R. 2022. Multi-agent pathfinding with continuous\ntomation,5628–5635. time. ArtificialIntelligence,305:103662. Sharon,G.;Stern,R.;Felner,A.;andSturtevant,N.R.2015. Cˇa´p,M.;Nova´k,P.;Vokr´ınek,J.;andPeˇchoucˇek,M.2013.",
      "size": 977,
      "sentences": 20
    },
    {
      "id": 61,
      "content": "nt pathfinding with continuous\ntomation,5628–5635. time. ArtificialIntelligence,305:103662. Sharon,G.;Stern,R.;Felner,A.;andSturtevant,N.R.2015. Cˇa´p,M.;Nova´k,P.;Vokr´ınek,J.;andPeˇchoucˇek,M.2013. Conflict-based search for optimal multi-agent pathfinding. ArtificialIntelligence,219:40–66. Multi-agent RRT: sampling-based cooperative pathfinding. In Proceedings of the International Conference on Au- Solis,I.;Motes,J.;Sandstro¨m,R.;andAmato,N.M.2021. tonomousAgentsandMulti-agentSystems,1263–1264. Representation-Optimal Multi-Robot Motion Planning Us-\ningConflict-BasedSearch. IEEERoboticsandAutomation\nChan,S.-H.;Chen,Z.;Guo,T.;Zhang,H.;Zhang,Y. ;Hara-\nLetters,6(3):4608–4615. bor, D.; Koenig, S.; Wu, C.; and Yu, J. 2024. The League\nofRobotRunnersCompetition:Goals,Designs,andImple- Stern,R.;Sturtevant,N.R.;Felner,A.;Koenig,S.;Ma,H. ;\nmentation. In Proceedings of the 34th International Con- Walker,T.T.;Li,J.;Atzmon,D.;Cohen,L.;Kumar,T.K.S.",
      "size": 949,
      "sentences": 19
    },
    {
      "id": 62,
      "content": "nersCompetition:Goals,Designs,andImple- Stern,R.;Sturtevant,N.R.;Felner,A.;Koenig,S.;Ma,H. ;\nmentation. In Proceedings of the 34th International Con- Walker,T.T.;Li,J.;Atzmon,D.;Cohen,L.;Kumar,T.K.S. ;\nference on Automated Planning and Scheduling – System Boyarski, E.; and Barta´k, R. 2019. Multi-Agent Pathfind-\nDemonstrationsTrack. ing:Definitions,Variants,andBenchmarks. InProceedings\nof the International Symposium on Combinatorial Search,\nCohen,L.;Uras,T.;Kumar,T.K.S.;andKoenig,S.2019. 151–159. Optimalandbounded-suboptimalmulti-agentmotionplan-\nning. In Proceedings of the International Symposium on Varambally, S.; Li, J.; and Koenig, S. 2022. Which MAPF\nCombinatorialSearch,volume10,44–51. Model Works Best for Automated Warehousing? In Pro-\nceedingsoftheInternationalSymposiumonCombinatorial\nErdmann,M. ;andLozano-Perez,T.1987.Onmultiplemov-\nSearch,volume15,190–198. ingobjects. Algorithmica,2:477–521. Walker, T. T.; Sturtevant, N. R.; and Felner, A. 2018.",
      "size": 968,
      "sentences": 18
    },
    {
      "id": 63,
      "content": "rnationalSymposiumonCombinatorial\nErdmann,M. ;andLozano-Perez,T.1987.Onmultiplemov-\nSearch,volume15,190–198. ingobjects. Algorithmica,2:477–521. Walker, T. T.; Sturtevant, N. R.; and Felner, A. 2018. Ex-\nGoldenberg, M.; Felner, A.; Stern, R.; Sharon, G.; Sturte-\ntendedIncreasingCostTreeSearchforNon-UnitCostDo-\nvant, N.; Holte, R. C.; and Schaeffer, J. 2014. Enhanced\nmains. InProceedingsofthe27thInternationalJointCon-\npartial expansion A*. Journal of Artificial Intelligence Re-\nferenceonArtificialIntelligence,534–540. search,50:141–187. Yan, J.; and Li, J. 2024. Multi-Agent Motion Planning\nHo,F.;Salta,A.;Geraldes,R.;Goncalves,A.;Cavazza,M. ;\nWithBe´zierCurveOptimizationUnderKinodynamicCon-\nandPrendinger,H.2019.Multi-AgentPathFindingforUAV\nstraints.IEEERoboticsandAutomationLetters,9(3):3021–\nTraffic Management. In Proceedings of the 18th Interna-\n3028.\ntional Conference on Autonomous Agents and MultiAgent\nSystems,131–139. Zhang,H.;Tiruviluamala,N.;Koenig,S.;andKumar,T.S. 2021.",
      "size": 989,
      "sentences": 19
    },
    {
      "id": 64,
      "content": "9(3):3021–\nTraffic Management. In Proceedings of the 18th Interna-\n3028.\ntional Conference on Autonomous Agents and MultiAgent\nSystems,131–139. Zhang,H.;Tiruviluamala,N.;Koenig,S.;andKumar,T.S. 2021. Temporalreasoningwithkinodynamicnetworks. In\nHo¨nig,W.;Kumar,T.K.S.;Cohen,L.;Ma,H.;Xu,H. ;Aya-\nProceedings of the International Conference on Automated\nnian, N.; and Koenig, S. 2016. Multi-agent path finding\nPlanningandScheduling,volume31,415–425. with kinematic constraints. In Proceedings of the Interna-\ntional Conference on Automated Planning and Scheduling,\nvolume26,477–485. Ho¨nig, W.; Kiesel, S.; Tinka, A.; Durham, J. W.; and Aya-\nnian, N. 2019. Persistent and Robust Execution of MAPF\nSchedules in Warehouses. IEEE Robotics and Automation\nLetters,4(2):1125–1131. Kou, N. M.; Peng, C.; Yan, X.; Yang, Z.; Liu, H.; Zhou,\nK.; Zhao, H.; Zhu, L.; and Xu, Y. 2019.",
      "size": 868,
      "sentences": 15
    },
    {
      "id": 65,
      "content": "Robust Execution of MAPF\nSchedules in Warehouses. IEEE Robotics and Automation\nLetters,4(2):1125–1131. Kou, N. M.; Peng, C.; Yan, X.; Yang, Z.; Liu, H.; Zhou,\nK.; Zhao, H.; Zhu, L.; and Xu, Y. 2019. Multi-agent path\nplanningwithnon-constantvelocitymotion.InProceedings\nofthe18thInternationalConferenceonAutonomousAgents\nandMultiAgentSystems,2069–2071. === 페이지 10 ===\nAppendix intervals, ensuring that a solution will be found if it exists. We then prove the optimality of SSIPP. Since the f-value\nTheoreticalProofs\nof an SSIPP node is a lower bound on the arrival times of\nLemma 1. Given travel time for rotate(θ ,θ ) is no\ni j its corresponding plan, the smallest f-value of the SSIPP\ngreater than the sum of travel time for rotate(θ ,θ ) and\ni k nodesinOPEN,denotedasf(n),isalowerboundonthear-\nrotate(θ ,θ ),∀θ ,duplicatedetectionmechanismdoesnot\nk j k rivaltimesofthecorrespondingpathsoftheSSIPPnodesin\naffectthecompletenessofSSIPP. OPEN. When f(n) ≥ travel time(p∗), no corresponding\nProof.",
      "size": 994,
      "sentences": 11
    },
    {
      "id": 66,
      "content": "rotate(θ ,θ ),∀θ ,duplicatedetectionmechanismdoesnot\nk j k rivaltimesofthecorrespondingpathsoftheSSIPPnodesin\naffectthecompletenessofSSIPP. OPEN. When f(n) ≥ travel time(p∗), no corresponding\nProof. Assume we have two SSIPP nodes n and n′ where pathsoftheSSIPPnodesinOPENcanhaveshorterarrival\nn.v = n′.v,n.θ = n′.θ,andn.ub = n′.ub,ifn.lb < n′.lb, timesthanp∗.SSIPPiscompleteandoptimal. we can only keep n in the OPEN without losing complete-\nTheorem 2. (Completeness and optimality of SSIPP with\nness. If n.a = n′.a, since both n and n′ can perform the\nPE).Thepartialexpansionmechanismdoesnotchangethe\nsame type of node expansion (either rotate expansion or\ncompletenessandoptimalityofSSIPP. moveexpansion),wecaneasilyprovethatpruningn′ does\nnotcompromisecompleteness. Proof.",
      "size": 775,
      "sentences": 9
    },
    {
      "id": 67,
      "content": "mechanismdoesnotchangethe\nsame type of node expansion (either rotate expansion or\ncompletenessandoptimalityofSSIPP. moveexpansion),wecaneasilyprovethatpruningn′ does\nnotcompromisecompleteness. Proof. The completeness of SSIPP is maintained because\nIn the case where n.a ̸= n′.a, it indicates that n′ can thepartialstationaryexpansionmechanism,whiledelaying\ngeneratedifferentchildnodesduringexpansion.Letn de- the exploration of some nodes, does not exclude any node\np\nnote the parent node of n, with n .a = n′.a. For any fromeventualexpansion.Asthesearchprogresses,allnodes\np\nchild node generated by n′, n can generate a correspond- with the potential to lead to a solution are eventually ex-\np\ningnodeatthesamevertexandorientation.Toprovecom- panded,ensuringthatasolution,ifoneexists,willbefound.",
      "size": 797,
      "sentences": 5
    },
    {
      "id": 68,
      "content": "y n′, n can generate a correspond- with the potential to lead to a solution are eventually ex-\np\ningnodeatthesamevertexandorientation.Toprovecom- panded,ensuringthatasolution,ifoneexists,willbefound. pleteness, we show that the child nodes generated by n at Wethenprovetheoptimalityispreservedwhenusingpartial\np\nthesamevertexandorientationalwayshaveasmallerlower stationaryexpansion.Eventhoughnotallchildrenofanode\nbound than those generated by n′. Let n and n′ represent are expanded immediately, we re-insert their parent node\np\nthe nodes generated at a given vertex and orientation by with updated f-value back to OPEN. The updated f-value\nn and n′, respectively. We define D(n ,n ) as the mini- is an underestimation of those child nodes. Thus, we can\np 1 2\nmum time required to transition from the state in n to the reuse the proof from Theorem 1. Therefore, partial expan-\n1\nstate in n . The lower bound for n can be represented by sionretainsthecompletenessandoptimalityinSSIPP.",
      "size": 985,
      "sentences": 8
    },
    {
      "id": 69,
      "content": "nsition from the state in n to the reuse the proof from Theorem 1. Therefore, partial expan-\n1\nstate in n . The lower bound for n can be represented by sionretainsthecompletenessandoptimalityinSSIPP. 2 p\nn .lb=n .lb+D(n ,n ),whilen′.lb=n′.lb+D(n′,n′). p p p p\nFromdefinition,wecanhave:\nn.lb=n .lb+D(n ,n) (3)\np p\nn .lb=n.lb−D(n ,n)+D(n ,n ) (4)\np p p p\nD(n,n )=D(n′,n′) (5)\np\nGivenD(n ,n )≤D(n ,n)+D(n,n ),thismeansmov-\np p p p\ning directly from n to n takes no more time than taking\np p\ntwosteps.CombinethiswithEq. (4)wecanhave:\nn .lb= n.lb−D(n ,n)+D(n ,n ) (6)\np p p p\n≤ n.lb+D(n,n ) (7)\np\nSincen.lb<n′.lb,usingEqs. (5)and(7)wecanhave:\nn .lb≤ n.lb+D(n,n ) (8)\np p\n< n′.lb+D(n′,n′) (9)\n= n′.lb (10)\nThus,weprovethatthechildnodesgeneratedbyn′ always\nhaveahigherlowerboundthanthosegeneratedbyn atthe\np\nsamevertexandorientation. Theorem 1. (Completeness and optimality of SSIPP). SSIPP is complete and returns the optimal solution if one\nexistswhenLevel3iscompleteandoptimal. Proof.",
      "size": 980,
      "sentences": 11
    },
    {
      "id": 70,
      "content": "eneratedbyn atthe\np\nsamevertexandorientation. Theorem 1. (Completeness and optimality of SSIPP). SSIPP is complete and returns the optimal solution if one\nexistswhenLevel3iscompleteandoptimal. Proof. WebeginbyprovingthecompletenessofSSIPPfol-\nlowed by the proof of its optimality. Since T contains a fi-\nnite number of safe intervals, the search space of SSIPP is\nfinite. Thus, SSIPP can terminate within a finite time if no\nsolutionexists.Duringthestationarynodeexpansion,given\nthat Level 3 is complete, we can explore all reachable safe",
      "size": 538,
      "sentences": 8
    }
  ]
}