{
  "source": "ArXiv",
  "filename": "020_MARPF__Multi-Agent_and_Multi-Rack_Path_Finding.pdf",
  "total_chars": 32625,
  "total_chunks": 47,
  "chunks": [
    {
      "id": 1,
      "content": "=== 페이지 1 ===\nMARPF: Multi-Agent and Multi-Rack Path Finding\nHiroya Makino1,∗, Yoshihiro Ohama1, and Seigo Ito1\nAbstract—In environments where many automated guided\nvehicles (AGVs) operate, planning efficient, collision-free paths\nis essential. Related research has mainly focused on environ-\nmentswithpre-definedpassages,resultinginspaceinefficiency. We attempt to relax this assumption. In this study, we define\nmulti-agent and multi-rack path finding (MARPF) as the (a) MAPF (conventional) (b) MARPF (proposed)\nproblem of planning paths for AGVs to convey target racks\nFig. 1: Environments of MAPF and MARPF. MAPF needs\ntotheirdesignatedlocationsinenvironmentswithoutpassages. In such environments, an AGV without a rack can pass under passages, whereas MARPF does not. racks,whereasonewitharackcannotpassunderrackstoavoid\ncollisions. MARPF entails conveying the target racks without\ncollisions,whiletheobstacleracksarerelocatedtopreventany\ninterference with the target racks.",
      "size": 979,
      "sentences": 9
    },
    {
      "id": 2,
      "content": "hereasonewitharackcannotpassunderrackstoavoid\ncollisions. MARPF entails conveying the target racks without\ncollisions,whiletheobstacleracksarerelocatedtopreventany\ninterference with the target racks. We formulated MARPF as\nan integer linear programming problem in a network flow. To\ndistinguish situations in which an AGV is or is not loading a\nrack, the proposed method introduces two virtual layers into (a) Actual Movement\nthe network. We optimized the AGVs’ movements to move w/rack layer\nobstacleracksandconveythetargetracks.Theformulationand w/o rack layer\napplicabilityofthealgorithmwerevalidatedthroughnumerical\nexperiments.Theresultsindicatedthattheproposedalgorithm\naddressed issues in environments with dense racks. move w/o a rack load move w/ a rack unload\n(b) Virtual Movement\nI. INTRODUCTION\nFig. 2: Two layers to express AGVs’ movements.",
      "size": 853,
      "sentences": 8
    },
    {
      "id": 3,
      "content": "ttheproposedalgorithm\naddressed issues in environments with dense racks. move w/o a rack load move w/ a rack unload\n(b) Virtual Movement\nI. INTRODUCTION\nFig. 2: Two layers to express AGVs’ movements. The\nOver the past few decades, introducing automated guided movementsbetweentheselayerscorrespondtowhetherthey\nvehicles(AGVs)inwarehousesandfactorieshasaccelerated are conveying a rack or not. When an AGV loads a rack, it\nefficiency.Numerouseffortshavebeendevotedtodeveloping virtuallytransitionsfromthe“w/orack”layertothe“w/rack”\nmulti-agent path finding (MAPF) for efficient transportation layer; unloading a rack reverses this transition. via AGVs [1]. This problem has been applied in many\nfields,suchasautomaticwarehouses[2],[3],airporttaxiway\ncontrol [4], and automated parking [5]. convey target racks to their designated locations in a grid-\nFor transportation in warehouses and factories, AGVs\nlike environment without passages.",
      "size": 937,
      "sentences": 9
    },
    {
      "id": 4,
      "content": "orttaxiway\ncontrol [4], and automated parking [5]. convey target racks to their designated locations in a grid-\nFor transportation in warehouses and factories, AGVs\nlike environment without passages. The racks cannot move\noften navigate beneath rack-type carts and convey entire\nand,thus,shouldbeconveyedbyAGVs.AGVswithoutracks\nrackswiththeircontents(hereinafterreferredtoasrack)toa\ncan pass under the racks; however, to avoid collisions, those\ndesignatedlocation.PriorresearchonMAPFhasmainlycon-\nwith racks cannot. MARPF involves conveying the target\nsidered navigating these racks through areas with passages\nracks to their designated destinations, while the obstacle\n(Fig.1(a)).However,thislayoutleadstotheinefficientuseof\nracks are situated freely. In an environment in which racks\nspace. In settings where sufficient space cannot be provided,\naredenselylocated,theobstaclerackscanbemovedtoavoid\nit is crucial to utilize the available area more effectively. interference with the target racks.",
      "size": 997,
      "sentences": 7
    },
    {
      "id": 5,
      "content": "ttings where sufficient space cannot be provided,\naredenselylocated,theobstaclerackscanbemovedtoavoid\nit is crucial to utilize the available area more effectively. interference with the target racks. TraditionalMAPFalgorithmsstruggletooptimizenavigation\nracksefficientlyinthesedenseenvironments(Fig.1(b)).The We formulated MARPF as an integer linear programming\ndifficulty lies in optimally relocating the obstacle racks. (ILP) problem in a network flow, which includes the AGV\nThisstudydefinesmulti-agentandmulti-rackpathfinding and rack networks. In the AGV network, the proposed\n(MARPF), which focuses on planning paths for AGVs to method distinguishes whether an AGV is conveying a rack\nusing two virtual layers (Fig. 2). The rack network rep-\n1 H.Makino,Y.Ohama,andS.ItoarewithToyotaCentralR&DLabs., resents the movements of the racks, which are separated\nInc.,41-1,Yokomichi,Nagakute,Aichi,Japan. from the AGVs.",
      "size": 917,
      "sentences": 8
    },
    {
      "id": 6,
      "content": "ig. 2). The rack network rep-\n1 H.Makino,Y.Ohama,andS.ItoarewithToyotaCentralR&DLabs., resents the movements of the racks, which are separated\nInc.,41-1,Yokomichi,Nagakute,Aichi,Japan. from the AGVs. By synchronizing the AGV network with\n∗ Correspondingauthor.hirom@mosk.tytlabs.co.jp\nthe rack network, the proposed method enables moving\n©2024IEEE.Personaluseofthismaterialispermitted.Permissionfrom\nIEEE must be obtained for all other uses, in any current or future media, obstacle racks and conveying target racks while avoiding\nincludingreprinting/republishingthismaterialforadvertisingorpromotional collisions. We aimed to solve the problem with various\npurposes, creating new collective works, for resale or redistribution to\nmovement constraints and minimize the makespan (i.e., the\nservers or lists, or reuse of any copyrighted component of this work in\notherworks. latest completion time). 4202\npeS\n5\n]AM.sc[\n3v67321.3042:viXra\n=== 페이지 2 ===\nA.",
      "size": 952,
      "sentences": 8
    },
    {
      "id": 7,
      "content": "nd minimize the makespan (i.e., the\nservers or lists, or reuse of any copyrighted component of this work in\notherworks. latest completion time). 4202\npeS\n5\n]AM.sc[\n3v67321.3042:viXra\n=== 페이지 2 ===\nA. Contribution Rack Position Goal\nR2 R2 R0\nOriginalmulti-agentpickupanddelivery(MAPD)focuses\nonly on conveying target racks. Other studies have consid- R0 R1 R1\nered switching the positions of racks [6], [7]. The difference\n(a) Unsolvable by rearrangement-considering MAPD\nbetween MARPF and rearrangement-considering MAPD is\nas follows: Rack Position Goal\n• MARPF: Only the target racks are assigned goals; the Free rack R0\nobstacle racks are situated freely. R0\n• Rearrangement-considering MAPD: All racks are as- (b) Solved by MARPF\nsigned goals. Fig. 3: Unsolvable example by MAPD. Itcouldbepositedthatrearrangement-consideringMAPD\ncan potentially address MARPF by assigning the same goal\npositionsastheinitialpositionsforobstacleracks.However, all racks must be assigned goals.",
      "size": 979,
      "sentences": 10
    },
    {
      "id": 8,
      "content": "D. Itcouldbepositedthatrearrangement-consideringMAPD\ncan potentially address MARPF by assigning the same goal\npositionsastheinitialpositionsforobstacleracks.However, all racks must be assigned goals. However, they do not\nwe estimate two typical situations where this assumption consider where and how obstacle racks are relocated, which\nmay not apply: (1) Environments with highly dense racks, is necessary for MARPF. where some situations cannot be solved by rearrangement-\nconsidering MAPD (Fig. 3). Sufficient conditions for solv- II. PROBLEMDEFINITION\nability are discussed in a sliding tile puzzle [8]; and (2) En-\nIn this section, we define the MARPF problem. As noted\nvironmentswithdenseracksandalimitednumberofAGVs,\ninSectionI,MARPFaimstoplanpathsforAGVstoconvey\nwhererelocatingrackstotheirinitialpositionswouldrequire\ntargetracksinanenvironmentwithoutpassages.TableIlists\nasignificantnumberoftimesteps.Theoptimizationproblem\nthe notation used in the following sections.",
      "size": 978,
      "sentences": 7
    },
    {
      "id": 9,
      "content": "ocatingrackstotheirinitialpositionswouldrequire\ntargetracksinanenvironmentwithoutpassages.TableIlists\nasignificantnumberoftimesteps.Theoptimizationproblem\nthe notation used in the following sections. of where to relocate the obstacle racks is challenging, and\nAn MARPF instance comprises M AGVs, N racks, and\nMARPF constitutes a new problem. an undirected grid graph, G=(V,E). The main contributions of this study are as follows:\nV ={v |x∈{0,...,size −1},y∈{0,...,size −1}},\n• We define a new problem (MARPF) of planning paths x,y x y\nfor AGVs to convey target racks to their designated E={(v x,y ,v x′,y′ )|v x,y ,v x′,y′ ∈V,|x−x′|+|y−y′|=1},\nlocations in dense environments. where v ∈V is the vertex with a column index x and\n• We propose a method for solving MARPF, formulated x,y\nrow index y in the grid. Diagonal edges are not considered\nas an ILP problem in a network flow. to avoid collisions between AGVs and the legs of racks.",
      "size": 935,
      "sentences": 7
    },
    {
      "id": 10,
      "content": "pose a method for solving MARPF, formulated x,y\nrow index y in the grid. Diagonal edges are not considered\nas an ILP problem in a network flow. to avoid collisions between AGVs and the legs of racks. • Solving thefull ILP problem wouldbe computationally\nloct(a),loct(r) ∈V denote the vertices of AGV a and\nintractable; therefore, we propose a hybrid approach i i i\nrack r at timestep t, respectively. cnvt(a)∈{0,1} refers\ncombined with cooperative A* (CA*) to allow feasible i i\ntotherack-conveyingstateofAGVa attimestept,where1\ncomputation times. i\nindicates that the AGV is conveying a rack, and 0 indicates\nB. Related Work otherwise. Time is assumed to be discretize. At each time step t, an\n1) MAPF: The MAPF problem relates to finding the\nAGV executes one of the following actions:\noptimal paths for multiple agents without collisions, and\nnumerous methods have been proposed [1]. As complete 1) Remain at the current location.",
      "size": 932,
      "sentences": 10
    },
    {
      "id": 11,
      "content": "inding the\nAGV executes one of the following actions:\noptimal paths for multiple agents without collisions, and\nnumerous methods have been proposed [1]. As complete 1) Remain at the current location. and optimal solvers, there are conflict-based search (CBS) loct(a i )=loct+1(a i ). [9],improvedCBS[10],andenhancedCBS[11].Prioritized 2) Move to the next location. planning, such as CA* [12] and multi-label A* [13], has a (cid:0) loct(a i ),loct+1(a i ) (cid:1) ∈E. short runtime but is suboptimal. MAPD [14] is a lifelong 3) Load a rack. variant of MAPF. Specifically, in MAPD, each agent is cnvt(a i )=0, cnvt+1(a i )=1, loct(a i )=loct+1(a i ). constantly assigned new tasks with new goal locations, 4) Unload a rack. whereas in MAPF, each agent has only one task. cnvt(a i )=1, cnvt+1(a i )=0, loct(a i )=loct+1(a i ).",
      "size": 823,
      "sentences": 12
    },
    {
      "id": 12,
      "content": "loct(a i )=loct+1(a i ). constantly assigned new tasks with new goal locations, 4) Unload a rack. whereas in MAPF, each agent has only one task. cnvt(a i )=1, cnvt+1(a i )=0, loct(a i )=loct+1(a i ). 2) Rearrangement-considering MAPD: In Double-Deck A rack also executes one of the following actions: remain\nMAPD (DD-MAPD) [6], agents are tasked to move racks to loct(r)=loct+1(r)ormove (cid:0) loct(r),loct+1(r) (cid:1) ∈E;how-\ni i i i\ntheir assigned delivery locations, thereby changing the over- ever, its movement depends on AGVs because the rack does\nall arrangement of the racks. The algorithm for DD-MAPD not move by itself. solves a DD-MAPD instance with M agents and N racks There should be no collisions between agents or racks. by first decomposing it into an N-agent MAPF instance, We define three types of collision for agents (Fig. 4): The\nand subsequently into a M-agent MAPD instance with task first is the vertex conflict [1], where two agents cannot be\ndependencies.",
      "size": 984,
      "sentences": 9
    },
    {
      "id": 13,
      "content": "nstance, We define three types of collision for agents (Fig. 4): The\nand subsequently into a M-agent MAPD instance with task first is the vertex conflict [1], where two agents cannot be\ndependencies. In Multi-Agent Transportation (MAT) [7], all in the same location at the same timestep. The second is the\nracksareassigneddeliverylocationswithoutfixedaisles.An swapping conflict [1], where two agents cannot move along\nalgorithm is provided for solving MAT by reducing it to a the same edge in opposite directions at the same timestep. series of satisfiability problems. In DD-MAPD and MAT, The third is the corner conflict. When an agent moves to the\n[표 데이터 감지됨]\n\n=== 페이지 3 ===\nTABLE I: Notations. AGV\nSymbols Description\nSection II and after\n(a) Vertex conflict (b) Swapping conflict (c) Corner conflict\na i AGV i\nr i Rack i Fig. 4: Type of conflicts.",
      "size": 853,
      "sentences": 9
    },
    {
      "id": 14,
      "content": "데이터 감지됨]\n\n=== 페이지 3 ===\nTABLE I: Notations. AGV\nSymbols Description\nSection II and after\n(a) Vertex conflict (b) Swapping conflict (c) Corner conflict\na i AGV i\nr i Rack i Fig. 4: Type of conflicts. x∈{0,...,sizex−1} Column index (sizex is the grid width)\ny∈{0,...,sizey−1} Row index (sizey is the grid height)\ntarget rack\nvx,y Vertex\ngoal\nV Set of vertices\nE Set of edges\nG=(V,E) Connected undirected graph obstacle\nt Timestep rack\nloct(a i ) Location vertex of a i at timestept (a) Initial positions (b) Process of (c) Process of\ncnvt(a i ) Rack-conveying state of a i & desired path moving obstacles re th a e c h ta in r g g e it t s r a g c o k al\nat timestept\nSection III and after Fig. 5: Problem example. G+ =(V+,E+) Time-expanded network representing\nag ag ag\nall AGVs’ movements\nG+ ar =(V a + r ,E a + r ) Time-expanded network representing III.",
      "size": 855,
      "sentences": 6
    },
    {
      "id": 15,
      "content": "timestept\nSection III and after Fig. 5: Problem example. G+ =(V+,E+) Time-expanded network representing\nag ag ag\nall AGVs’ movements\nG+ ar =(V a + r ,E a + r ) Time-expanded network representing III. PROPOSEDMETHOD\nall racks’ movements\nG+=(V+,E+) Time-expanded network representing In this section, we formulate MARPF as a minimum-cost\ntr tr tr\nthe target rack’s movements flow problem in a network flow, similar to the approaches\nT Set of timesteps in time-expanded for MAPF [5], [15]. Two types of synchronized networks\nnetworks\nare established, one for AGVs and the other for racks. The\nc(·) Cost function of flow\nnetwork for AGVs distinguishes whether or not an AGV\nl Layer (w/rack or w/o rack)\nSag,Sar,Str⊆V Start location vertices of all AGVs, is conveying a rack using two virtual layers to represent\nall racks, and the target racks, conveying a rack. respectively\nTtr⊆V Goal location vertex of the target rack A.",
      "size": 920,
      "sentences": 7
    },
    {
      "id": 16,
      "content": "cation vertices of all AGVs, is conveying a rack using two virtual layers to represent\nall racks, and the target racks, conveying a rack. respectively\nTtr⊆V Goal location vertex of the target rack A. Definition of Networks\nαt ,βt ,γt Flow on E+,E+,E+, respectively\nvi,vo,li,lo vi,vo vi,vo ag ar tr When AGVs are not conveying a rack, their obstacles are\nthe other AGVs; however, when they are conveying a rack,\nother racks also become obstacles. Therefore, whether an\nother agent’s position and their adjacent agent’s movements AGVisconveyingarackontoatime-expandednetworkmust\nare in a vertical relationship, their corners collide, as shown bedetermined.TheAGVs’movementsareclassifiedintothe\nin Fig. 4(c). following four actions in terms of the rack-conveying state\nFormally, for all agents a,a (i̸= j) and all timesteps t, (Fig. 2(a)):\ni j\nthe following equations must hold to avoid collisions: 1) Move(orremainatthecurrentlocation)withoutarack. 2) Load a rack.",
      "size": 962,
      "sentences": 8
    },
    {
      "id": 17,
      "content": "te\nFormally, for all agents a,a (i̸= j) and all timesteps t, (Fig. 2(a)):\ni j\nthe following equations must hold to avoid collisions: 1) Move(orremainatthecurrentlocation)withoutarack. 2) Load a rack. loct(a i )̸=loct(a j ), (1) 3) Move (or remain at the current location) with a rack. loct(a)=loct+1(a ) 4) Unload a rack. i j\n⇒ (cid:0) loct+1(a) −loct(a) (cid:1) = (cid:0) loct+1(a ) −loct(a ) (cid:1) Our proposed method divides a moving plane into two\ni x i x j x j x\nvirtual layers to represent two situations: conveying or not\n∧ (cid:0) loct+1(a) −loct(a) (cid:1) = (cid:0) loct+1(a ) −loct(a ) (cid:1) ,\ni y i y j y j y conveying a rack (Fig. 2(b)). (2)\nThe rack-loading action corresponds to movement from\nthe w/o to the w/rack layers, and vice versa. where loct(a) and loct(a) denote the column and row\ni x i y Then, all vertices are expanded along the time-axis, and\nindicesofloct(a),respectively. (1)representsthevertexcon-\ni under specific constraints, directed edges are added. The\nflict.",
      "size": 999,
      "sentences": 11
    },
    {
      "id": 18,
      "content": "n and row\ni x i y Then, all vertices are expanded along the time-axis, and\nindicesofloct(a),respectively. (1)representsthevertexcon-\ni under specific constraints, directed edges are added. The\nflict. (2) represents both the swapping and corner conflicts. edges indicate AGV motion in the grid. The motions are\nThese three types of collision are also applied to racks. distinguished by the indices (x,y) of the source and sink\nThe MARPF problem involves computing collision-free vertices and the virtual layers, where the motion is with\npaths for AGVs and minimizing the timesteps required to (l=1) and without (l=0) a rack. Fig. 6 (upper) shows an\nconvey the target racks to their designated locations. Non- exampleofatime-expandednetworkrepresentingallAGVs’\ntarget racks act as obstacles and are positioned freely. movements. For simplicity, Figs. 2 and 6 show the moving\nFig.5exemplifiesmovingaracktoavoidinterferencewith plane in one dimension; however, it is two-dimensional.",
      "size": 979,
      "sentences": 13
    },
    {
      "id": 19,
      "content": "bstacles and are positioned freely. movements. For simplicity, Figs. 2 and 6 show the moving\nFig.5exemplifiesmovingaracktoavoidinterferencewith plane in one dimension; however, it is two-dimensional. the movement of the target rack. The path the AGV must For the racks’ movements, the networks should be sepa-\nfollow to convey the target rack to its designated location is rated from the AGVs. Distinguishing the layers in a time-\nblocked by an obstacle rack (Fig. 5(a)). First, the obstacle expanded network is not necessary (Fig. 6 (lower)). The\nrack is removed (Fig. 5(b)), and the target rack is then flows expressing the movements of racks are synchronized\nconveyed to the designated location (Fig. 5(c)). with the corresponding flows of AGVs. [표 데이터 감지됨]\n\n=== 페이지 4 ===\nWe define the time-expanded network representing all of timesteps T \\{size −1} refers to T−.",
      "size": 868,
      "sentences": 15
    },
    {
      "id": 20,
      "content": "d to the designated location (Fig. 5(c)). with the corresponding flows of AGVs. [표 데이터 감지됨]\n\n=== 페이지 4 ===\nWe define the time-expanded network representing all of timesteps T \\{size −1} refers to T−. t\nAGVs, all racks, and the target rack’s movements as di-\nrected graphs G+ =(V+,E+), G+ =(V+,E+), and G+= min∑c(vi,vo,li,lo,t)α v t i,vo,li,lo (9)\nag ag ag ar ar ar tr\n(V+,E+), respectively. G+ has the same structure as G+; s.t. tr tr tr ar\nhowever,thetargetrackisdistinguishedfromtheotherracks. ∑αt = ∑ αt+1 ∀v∈V,l∈{0,1},t∈T−\nThe goal location of the target rack is fixed on G t + r .",
      "size": 585,
      "sentences": 8
    },
    {
      "id": 21,
      "content": "ely. G+ has the same structure as G+; s.t. tr tr tr ar\nhowever,thetargetrackisdistinguishedfromtheotherracks. ∑αt = ∑ αt+1 ∀v∈V,l∈{0,1},t∈T−\nThe goal location of the target rack is fixed on G t + r . vi,li vi,v,li,l vo,lo v,vo,l,lo\n(10)\nV+={vt |x∈{0,...,size −1},y∈{0,...,size −1},\nag x,y,l x y ∑βt =∑βt+1 ∀v∈V,t∈T− (11)\nl∈{0,1},t∈{0,...,size}}, vi,v v,vo\nt vi vo\nE a + g ={⟨vt x,y,l ,vt x ′ ′,y′,l′ ⟩|vt x,y,l ,vt x ′ ′,y′,l′ ∈V a + g , ∑γ v t i,v =∑γ v t , + vo 1 ∀v∈V,t∈T− (12)\n|x−x′|+|y−y′|≤1,t′−t=1}, vi vo\nV a + r ,V t + r ={vt x,y |x∈{0,...,size x −1}, β v t i,vo =α v t i,vo,1,1 ∀(vi,vo)∈E,t∈T (13)\ny∈{0,...,size −1},t∈{0,...,size}}, γt ≤βt ∀vi,vo∈V,t∈T (14)\ny t vi,vo vi,vo\nE a + r ,E t + r ={⟨vt x,y ,vt x ′ ′,y′ ⟩|vt x,y ,vt x ′ ′,y′ ∈V a + r , α v t ,v,0,1 ≤∑β v t i,v ∀v∈V,t∈T (15)\n|x−x′|+|y−y′|≤1,t′−t=1}, vi\n∑ αt ≤1 ∀v∈V,t∈T (16)\nvi,v,li,lo\nwhere size t denotes the maximum timesteps in the time- vi,li,lo\nexpanded network.",
      "size": 938,
      "sentences": 5
    },
    {
      "id": 22,
      "content": "′,y′ ∈V a + r , α v t ,v,0,1 ≤∑β v t i,v ∀v∈V,t∈T (15)\n|x−x′|+|y−y′|≤1,t′−t=1}, vi\n∑ αt ≤1 ∀v∈V,t∈T (16)\nvi,v,li,lo\nwhere size t denotes the maximum timesteps in the time- vi,li,lo\nexpanded network. The value of size t is set large enough ∑β v t i,v ≤1 ∀v∈V,t∈T (17)\nfor the target agent to reach the goal. Dependencies exist vi\nbetween G+ and G+ and between G+ and G+, and their ∑αt + ∑ αt\nar ag tr ar vi,vo,li,lo vo,v,li,lo\nflows are synchronized. li,lo v,li,lo\n≤ ∑ α v t o,vˆ,li,lo +1 ∀(vi x,y ,vo x′,y′ )∈E,t∈T\nB. Definition of Variables\nvˆ 2x′−x,2y′−y ,li,lo\nThe vertices on V+ are distinguished by t,v, and l. Each (18)\nag\nedge consists of the source and sink vertices. α v t i,vo,li,lo Theobjectivefunction(9)definesthecostfunction,which\nrepresents the flow on the edge ⟨vt vix,viy,li ,vt v + ox 1 ,voy,lo ⟩∈E a + g . implies that the timestep t is directly proportional to the\nHere, vi,vo∈V,li,lo∈{0,1} respectively denote the source movement cost.",
      "size": 956,
      "sentences": 7
    },
    {
      "id": 23,
      "content": "he flow on the edge ⟨vt vix,viy,li ,vt v + ox 1 ,voy,lo ⟩∈E a + g . implies that the timestep t is directly proportional to the\nHere, vi,vo∈V,li,lo∈{0,1} respectively denote the source movement cost. Therefore, this problem calculates the flows\nvertex, sink vertex, source layer, and sink layer, and t ∈ withtheminimumnumberofstepstoconveythetargetrack\nT ={0,...,size t −1}representsthesourcevertex’stimestep. from the initial to the goal position. G+,G+donotcontainmultiplelayers;therefore,theflowsof Constraints (10)–(12) are required to satisfy the flow\nar tr\nracks are expressed more simply as βt ,γt , respectively. conservation constraints at the vertices. Racks are conveyed\nvi,vo vi,vo\nWedefinethevariablesandthecostfunctionc(·)asfollows: by AGVs, and (13) indicates that the flows of the racks’\nmovements on G+ are equal to the corresponding flow on\nα v t i,vo,li,lo ,β v t i,vo ,γ v t i,vo ∈{0,1}, (3) G+.",
      "size": 915,
      "sentences": 7
    },
    {
      "id": 24,
      "content": "dthecostfunctionc(·)asfollows: by AGVs, and (13) indicates that the flows of the racks’\nmovements on G+ are equal to the corresponding flow on\nα v t i,vo,li,lo ,β v t i,vo ,γ v t i,vo ∈{0,1}, (3) G+. Constraint (1 a 3 r ) indicates that G+ depends on G+ and\nag ar ag\n(cid:26) 0 if vi=vo,li=lo (14)indicatesthatG+ dependsonG+.Considering(7),(12),\nc(vi,vo,li,lo,t)= . (4) tr ar\nt+1 otherwise and (14), only flows related to the movement of the target\nrackonG+ arereflectedinG+.Constraint(15)indicatesthat\nWe define the initial location vertices of all AGVs, racks, ar tr\na rack must exist where an AGV loads a rack (αt =1). and the target rack, respectively, as S ,S , and S , where v,v,0,1\nag ar tr Eq. ∑ βt =1 indicates that one of the flows to vertex v is\nS ⊆S . In the network, we express the initial locations by vi vi,v\ntr ar 1; that is, a rack is placed at vertex v. Constraints (16) and\nfixing the flows att=0 (respectively, (5), (6), and (7)).",
      "size": 950,
      "sentences": 6
    },
    {
      "id": 25,
      "content": "v is\nS ⊆S . In the network, we express the initial locations by vi vi,v\ntr ar 1; that is, a rack is placed at vertex v. Constraints (16) and\nfixing the flows att=0 (respectively, (5), (6), and (7)). The\n(17) prohibit AGVs and racks from coexisting at the same\ngoal location vertex of the target rack, T , is defined by (8). tr vertices, respectively. Constraint (18) is required to prevent\n(cid:26) α0 =1 if vi=vo∈S ,li=lo=0 theswappingconflictandthecornerconflictbetweenagents. α v 0 i,vo,li,lo =0 otherwise ag (5) The above formulation is for one target rack. However,\nvi,vo,li,lo\ntheformulationcanbeextendedtomultipletargetracks.The\n(cid:26) β0 =1 if vi=vo∈S\nvi,vo ar (6) network representing the movement of the i-th target rack is\nβ v 0 i,vo =0 otherwise referred to as G t + r ,i=(V t + r ,i,E t + r ,i). The corresponding flow is\n(cid:26) γ0 =1 if vi=vo∈S γ t,i and the constraints are the same as γt .",
      "size": 909,
      "sentences": 8
    },
    {
      "id": 26,
      "content": "f the i-th target rack is\nβ v 0 i,vo =0 otherwise referred to as G t + r ,i=(V t + r ,i,E t + r ,i). The corresponding flow is\n(cid:26) γ0 =1 if vi=vo∈S γ t,i and the constraints are the same as γt . vi,vo tr (7) vi,vo vi,vo\nγ0 =0 otherwise\nvi,vo D. Applications for Real-Time Solving\n(cid:40)\nγsizet−1=1 if vi=vo∈T\nvi,vo tr (8) Theproposedmethodcomplicatesthenetworkwithlonger\nγ v s i i , z v e o t−1=0 otherwise path lengths and the computational cost increases exponen-\ntially.Webelievethatappropriatelydividingthepathreduces\nC. Minimum Cost Flow Problem\nthe computational costs. Hence, we propose an acceleration\nThe aim is to convey the target rack from the starting method combined with CA*, called CA*-ILP. This method\nposition to the goal position as quickly as possible. The set comprises global and local searches.",
      "size": 824,
      "sentences": 6
    },
    {
      "id": 27,
      "content": "is to convey the target rack from the starting method combined with CA*, called CA*-ILP. This method\nposition to the goal position as quickly as possible. The set comprises global and local searches. The global search finds\n=== 페이지 5 ===\n(x, y, l) = (2, 0, 1)\nAGVs\n(x, y, l) = (2, 0, 0) Move (or remain)\nw/o a rack\n(x, y, l) = (1, 0, 1)\nLoad a rack\n(x, y, l) = (1, 0, 0)\nMove (or remain)\nw/ a rack\n(x, y, l) = (0, 0, 1)\n(x, y, l) = (0, 0, 0) Unload a rack\nsynchronized\n(x, y) = (2, 0)\nRacks\n(x, y) = (1, 0)\nMove (or remain)\n(x, y) = (0, 0)\nt = 0 t = 1 t = 2 t = 3 t = 4\nFig. 6: Time-expanded networks for AGVs (upper) and racks (lower). Loading or unloading a rack (blue and yellow arrows,\nrespectively) only changes the loading status l, whereas moving (red and green arrows) changes the position x or y but not\nl. The two networks are synchronized, and the movement of racks depends on the movement of AGVs.",
      "size": 909,
      "sentences": 6
    },
    {
      "id": 28,
      "content": "hanges the loading status l, whereas moving (red and green arrows) changes the position x or y but not\nl. The two networks are synchronized, and the movement of racks depends on the movement of AGVs. The movement of\nthe AGV and racks at the top of the figure corresponds to the thick arrows. waypoints to divide the path, and the local search explores methods; and (2) an evaluation of the effectiveness of CA*-\nthe paths between each waypoint. ILP.Fortheexperimentalsetup,thetime-expandednetworks\nCA* is an extension of the A* algorithm, tailored for were represented by NetworkX1 and the optimization prob-\nmulti-agent scenarios. It allows multiple agents to plan their lem was defined by PuLP2. We used the GUROBI solver3. paths sequentially, avoiding collisions through a reservation AlltheexperimentswererunonasystemcomprisingUbuntu\ntable that records and manages the paths of all agents. This 22.04, Intel Core i9-12900K, and 128 GiB of RAM.",
      "size": 947,
      "sentences": 8
    },
    {
      "id": 29,
      "content": "oiding collisions through a reservation AlltheexperimentswererunonasystemcomprisingUbuntu\ntable that records and manages the paths of all agents. This 22.04, Intel Core i9-12900K, and 128 GiB of RAM. ensures that each agent’s path is optimized while preventing Weperformedalltheexperimentsin6×4grids.Although\noverlaps in their paths. this size is too small for automated warehouses, small-\nFirst, path finding is performed using CA* for the global sized environments, such as inter-process transportation, are\nsearch. In this step, the racks are assumed to move by them- utilized in specific areas of the factories. selves, and collisions between racks are allowed. However,\nfrom the viewpoint of timesteps, removing obstacle racks A. Experiment 1: Comparative Evaluation of the Proposed\nshould be avoided. Therefore, moving to a location with a Method against Existing Methods\nrack is defined as incurring a κ>1 cost in CA*.",
      "size": 925,
      "sentences": 9
    },
    {
      "id": 30,
      "content": "racks A. Experiment 1: Comparative Evaluation of the Proposed\nshould be avoided. Therefore, moving to a location with a Method against Existing Methods\nrack is defined as incurring a κ>1 cost in CA*. Moving to\nWe compared our initially proposed method, an ILP-\na location with no racks incurs a cost of +1. Algorithm 1\nbased method (independent of CA*), against widely used\npresents the corresponding pseudo-code. MAPF solvers, CA* and CBS. In MARPF, the other racks\nWe define span length τ between two waypoints before\nbecome obstacles only when the AGV conveys a rack. We\nprocedure. A large span length brings the solution closer\nused CA* and CBS for comparison, which accounts for\nto the global optimum; however, the computational cost\nthese conditions. In the first step, the AGVs moved to\nincreases. In the pseudo code, the global search executes\nthe initial locations of the target racks without collisions\nCA* [line 1]. It chooses the waypoints according to the\nbetween AGVs.",
      "size": 982,
      "sentences": 12
    },
    {
      "id": 31,
      "content": "s moved to\nincreases. In the pseudo code, the global search executes\nthe initial locations of the target racks without collisions\nCA* [line 1]. It chooses the waypoints according to the\nbetween AGVs. In the second step, the AGVs moved to the\nglobalpaths[lines2–7].Thegoallocationsarealsoincluded\ngoal locations of the target racks without collisions between\nin the waypoints [line 8]. AGVs and between racks. Second, the local search repeatedly solves the local path-\nThere were initially two AGVs and six racks, including\nfinding problem. Algorithm 2 presents the pseudo-code. targets. The racks were then added sequentially. Fig. 7(a)\nThe local path-finding problem, which involves conveying\nillustrates this environment. Two obstacle racks could block\nmultiple racks to their waypoints, is solved using ILP [line\nthe paths. For example, two racks were placed in the lower-\n3].Thetargetracksdonotalwaysarriveattheirwaypointsi-\nleft region (Fig. 7(b)).",
      "size": 953,
      "sentences": 14
    },
    {
      "id": 32,
      "content": "multiple racks to their waypoints, is solved using ILP [line\nthe paths. For example, two racks were placed in the lower-\n3].Thetargetracksdonotalwaysarriveattheirwaypointsi-\nleft region (Fig. 7(b)). We performed 30 experiments at\nmultaneously.Whenoneoftheracksarrivesatitswaypoint,\ndifferent locations to add the racks. The solver’s time limit\na local search is performed again [lines 4–8]. was 120 s, and size was set to 40.\nt\nIV.",
      "size": 431,
      "sentences": 6
    },
    {
      "id": 33,
      "content": "ltaneously.Whenoneoftheracksarrivesatitswaypoint,\ndifferent locations to add the racks. The solver’s time limit\na local search is performed again [lines 4–8]. was 120 s, and size was set to 40.\nt\nIV. EXPERIMENTS 1https://networkx.org/\n2https://coin-or.github.io/pulp/\nIn this section, we describe two experiments: (1) a com-\n3https://www.gurobi.com/solutions/\nparative evaluation of the proposed method against existing gurobi-optimizer/\n=== 페이지 6 ===\nR1 goal R0 goal\nR1 R0\nAlgorithm 1 Global Search\nAGV Rack\nInput:GraphG,racks(i-thrackmovesfromni toni) Area where\n0 g racks are added\nParameter:Spanlengthτ betweentwowaypoints\nOutput:Sequencesofwaypointswaypoints Target rack R0 R0 R1 Target rack R1\n1: Find the global paths of the target racks using CA*: path[i] = (a) Initial environment\n(ni,ni,...,ni),whichisavertexsequence.",
      "size": 828,
      "sentences": 4
    },
    {
      "id": 34,
      "content": "tput:Sequencesofwaypointswaypoints Target rack R0 R0 R1 Target rack R1\n1: Find the global paths of the target racks using CA*: path[i] = (a) Initial environment\n(ni,ni,...,ni),whichisavertexsequence. 0 1 g\n2: forallido R1 R0\n3: waypoints[i]=[]\n4: index=0\n5: whileindex<|path[i]|−1do\n6: waypoints[i]←add path[i][current index]\n7: index=index+τ R0 R1\n8: waypoints[i]←addni\ng (b) A typical environment that is challenging\n9: Returnwaypoints for CBS and CA* to solve\nFig. 7: Environment of Exp. 1.",
      "size": 493,
      "sentences": 4
    },
    {
      "id": 35,
      "content": "s[i]←add path[i][current index]\n7: index=index+τ R0 R1\n8: waypoints[i]←addni\ng (b) A typical environment that is challenging\n9: Returnwaypoints for CBS and CA* to solve\nFig. 7: Environment of Exp. 1. 1.0\nAlgorithm 2 Local Search\n0.8\nInput:GraphG,agents,racks,waypointswaypoints\nOutput:Pathsofallagentsandracks paths\n0.6\n1: paths=[] 0.4\n2: whilenotallrackshavearrivedattheirwaypointsdo\n3: UseILPtocalculatepathstemp pathsforalltargetracksfromtheir\n0.2\ncurrentpositiontotheirrespectivewaypoints\n4: mint istheminimumlengthoftemp paths\n0.0\n5: foralliinallagentsandracksdo\n0 1 2 3 4 5 6 7\n6: Updatethe paths[i]withthetemp paths[i][:mint+1]\nNum of Added Racks\n7: Updatethecurrentpositionwithtemp paths[i][mint]\n8: Checkifeachrackhasreacheditswaypoint\n9: Return paths\nFig.8showsacomparisonofthesuccessratesandaverage\nmakespans of the successful tasks4. As Fig. 8 shows, with\nfew added racks, all methods succeeded. However, with\nmany added racks, CA* and CBS sometimes failed to find\nthe path.",
      "size": 986,
      "sentences": 7
    },
    {
      "id": 36,
      "content": "successratesandaverage\nmakespans of the successful tasks4. As Fig. 8 shows, with\nfew added racks, all methods succeeded. However, with\nmany added racks, CA* and CBS sometimes failed to find\nthe path. CA* and CBS consider only the movements of the\ntarget racks and cannot remove obstacle racks. Therefore,\nthey could not find the path when many racks were added\nandthepathswereblocked.Ourproposedmethodconsidered\nall rack movements, and as a result, it found the movement\nnecessary for removing obstacle racks. Although the proposed method is theoretically capable\nof solving these problems if there are one or more empty\nvertices, it failed in half of the tasks when adding six racks. When the problem was complex and the computational cost\nwas high, the solver failed to find a path within the time\nlimit. Therefore, we evaluated an acceleration method in the\nfollowing experiment.",
      "size": 882,
      "sentences": 9
    },
    {
      "id": 37,
      "content": ". When the problem was complex and the computational cost\nwas high, the solver failed to find a path within the time\nlimit. Therefore, we evaluated an acceleration method in the\nfollowing experiment. B. Experiment2:EvaluationoftheEffectivenessofCA*-ILP\nSolving the path-finding problem using the proposed\nmethod was computationally expensive. We confirmed that\nCA*-ILPreducedthecomputationalcost.Weassignedacost\n4In Fig. 8, there was no difference between CA* and CBS in such a\nsimpleenvironment. etaR\nsseccuS\nCA*\nCBS\nILP\nFig. 8: Comparison of success rates on Exp. 1.\nκ =3 to move to a location occupied by a rack5. The evaluations were conducted in sparse (12 racks) and\ndense (18 racks) environments. Each environment contained\neightAGVs.Fig.9isanexampleofadenseenvironment.We\nperformed 30 experiments using the AGVs and non-target\nracks in different initial locations to compare the makespans\nof the tasks of conveying the two target racks to their goals.",
      "size": 959,
      "sentences": 11
    },
    {
      "id": 38,
      "content": "denseenvironment.We\nperformed 30 experiments using the AGVs and non-target\nracks in different initial locations to compare the makespans\nof the tasks of conveying the two target racks to their goals. ThecomparisonofthemakespansisshowninTableII,with\nthe differences in span lengths between waypoints (CA*-\nILP) highlighted. Fig. 10 also shows a comparison of the\nmakespansbetweentheinitiallyproposedmethod(ILP-only)\nand the acceleration method (CA*-ILP). We set the time\nlimit of 120s for each local search conducted by CA*-ILP,\nand each size was set to 24. ILP-only was computationally\nt\nexpensive; therefore, we set the time limit to three different\nvalues,120s,240s,and1200s,andcomparedthem.size was\nt\nset to 40. In the dense environment (Fig. 10(b))6, ILP-only\nfailed to find solutions in some experiments within the time\nlimits of 120s and 240s. First, we evaluated the difference in span between way-\npoints (CA*-ILP). According to Table II, Span 4 yielded\nthe best result.",
      "size": 978,
      "sentences": 10
    },
    {
      "id": 39,
      "content": "solutions in some experiments within the time\nlimits of 120s and 240s. First, we evaluated the difference in span between way-\npoints (CA*-ILP). According to Table II, Span 4 yielded\nthe best result. Span 1, being excessively fine-grained and\nignoring future rack locations, had a larger makespan. We\nadopted Spans 2 and 4 for the subsequent comparisons. 5Wesetthecostκ to3becauseweassumedthatthetaskinvolvedthree\nsteps:loading,moving,andunloadingtheobstaclerack. 6Thecalculationtimeincludedthetimerequiredfornetworkconstruction. [표 데이터 감지됨]\n\n=== 페이지 7 ===\nR1 goal\nR1 R0\nR0 goal\nAGV\nRack\nTarget rack\nR0 R0 R1 Target rack\nR1\nFig. 9: Example of the environment in Exp. 2. TABLE II: Comparison of CA*-ILP makespans on Exp. 2. Span length τ between waypoints 1 2 4\n12 racks 21.9 18.1 14.8\n20 racks 39.9 28.9 23.9\n40\n30\n20\n10\n0\n0 500 1000\nCalculation Time [s]\nnapsekaM\nthat the acceleration method reduced computational cost.",
      "size": 920,
      "sentences": 13
    },
    {
      "id": 40,
      "content": ". Span length τ between waypoints 1 2 4\n12 racks 21.9 18.1 14.8\n20 racks 39.9 28.9 23.9\n40\n30\n20\n10\n0\n0 500 1000\nCalculation Time [s]\nnapsekaM\nthat the acceleration method reduced computational cost. Whileweacknowledgetheneedforfurtherresearchonmore\nefficientalgorithms,itissufficientifthepathsarecalculated\nbefore the following product is completed in conveyance\nbetweenproductionprocessesinfactories.Intheseinstances,\nour proposed algorithm can be practically applied. Although we performed our experiments on a small grid,\nthe problem setting of MARPF can be applied to large-scale\nwarehouses.However,solvingbiggerproblemsincreasesthe\ncomputationalcost.Inthefuture,weplantoinvestigatemore\nefficient and faster algorithms. ACKNOWLEDGMENTS\n40 We thank Kenji Ito, Tomoki Nishi, Keisuke Otaki, and\nYasuhiro Yogo for their helpful discussions.",
      "size": 841,
      "sentences": 5
    },
    {
      "id": 41,
      "content": "utationalcost.Inthefuture,weplantoinvestigatemore\nefficient and faster algorithms. ACKNOWLEDGMENTS\n40 We thank Kenji Ito, Tomoki Nishi, Keisuke Otaki, and\nYasuhiro Yogo for their helpful discussions. 30\nREFERENCES\n20 [1] R.Stern,N.Sturtevant,A.Felner,S.Koenig,H.Ma,T.Walker,J.Li,\nD. Atzmon, L. Cohen, T. K. Kumar, R. Barta´k, and E. Boyarski,\nILP-only “Multi-AgentPathfinding:Definitions,Variants,andBenchmarks,”in\n10\nCA*-ILP (span 2) ProceedingsoftheInternationalSymposiumonCombinatorialSearch,\nvol.10,2019,pp.151–158. CA*-ILP (span 4)\n0 [2] P.R.Wurman,R.D’Andrea,andM.Mountz,“CoordinatingHundreds\n0 500 1000 ofCooperative,AutonomousVehiclesinWarehouses.”AIMagazine,\nCalculation Time [s] vol.29,no.1,pp.9–20,2008. (a) 12 Racks (b) 18 Racks [3] W. Honig, S. Kiesel, A. Tinka, J. W. Durham, and N. Ayanian,\n“PersistentandRobustExecutionofMAPFSchedulesinWarehouses,”\nFig. 10: Comparison of makespans on Exp. 2. IEEERoboticsandAutomationLetters,vol.4,no.2,pp.1125–1131,\n2019.",
      "size": 972,
      "sentences": 8
    },
    {
      "id": 42,
      "content": "a, J. W. Durham, and N. Ayanian,\n“PersistentandRobustExecutionofMAPFSchedulesinWarehouses,”\nFig. 10: Comparison of makespans on Exp. 2. IEEERoboticsandAutomationLetters,vol.4,no.2,pp.1125–1131,\n2019. [4] J.Li,H.Zhang,M.Gong,Z.Liang,W.Liu,Z.Tong,L.Yi,R.Morris,\nC.Pasareanu,andS.Koenig,“SchedulingandAirportTaxiwayPath\nSecond,wecomparedtheinitiallyproposedmethod(ILP- PlanningUnderUncertainty,”inProceedingsofthe2019Aviationand\nonly) with the acceleration method (CA*-ILP). In the sparse AeronauticsForumandExposition,2019,pp.1–8. environment (Fig. 10(a)), CA*-ILP exhibited a shorter to- [5] A.Okoso,K.Otaki,S.Koide,andT.Nishi,“HighDensityAutomated\nValet Parking via Multi-agent Path Finding,” in 2022 IEEE 25th In-\ntal calculation time compared with ILP-only; however, its ternationalConferenceonIntelligentTransportationSystems(ITSC),\nmakespanwaslarger.CA*-ILPdividedthepathsintoseveral 2022,pp.2146–2153.",
      "size": 906,
      "sentences": 8
    },
    {
      "id": 43,
      "content": "5th In-\ntal calculation time compared with ILP-only; however, its ternationalConferenceonIntelligentTransportationSystems(ITSC),\nmakespanwaslarger.CA*-ILPdividedthepathsintoseveral 2022,pp.2146–2153. [6] B. Li and H. Ma, “Double-Deck Multi-Agent Pickup and Deliv-\nparts, each easier to solve, thereby reducing the overall\nery: Multi-Robot Rearrangement in Large-Scale Warehouses,” IEEE\ncalculationcostcomparedtoILP-only.However,becausethe RoboticsandAutomationLetters,pp.1–8,2023. waypointsinCA*-ILPwerenotalwaysoptimal,itsmakespan [7] P. Bachor, R.-D. Bergdoll, and B. Nebel, “The Multi-Agent Trans-\nexceeded that of the global optimal solution by ILP-only. portationProblem,”inProceedingsoftheAAAIConferenceonArtifi-\ncialIntelligence,vol.37,2023,pp.11525–11532. In the dense environment (Fig. 10(b)), the makespan of [8] W.W.JohnsonandW.E.Story,“Notesonthe“15”Puzzle,”American\nCA*-ILPwassmallerthanILP-only,andthetotalcalculation JournalofMathematics,vol.2,no.4,pp.397–404,1879.",
      "size": 980,
      "sentences": 6
    },
    {
      "id": 44,
      "content": "ronment (Fig. 10(b)), the makespan of [8] W.W.JohnsonandW.E.Story,“Notesonthe“15”Puzzle,”American\nCA*-ILPwassmallerthanILP-only,andthetotalcalculation JournalofMathematics,vol.2,no.4,pp.397–404,1879. time of CA*-ILP was considerably shorter than ILP-only. [9] G.Sharon,R.Stern,A.Felner,andN.R.Sturtevant,“Conflict-based\nsearchforoptimalmulti-agentpathfinding,”ArtificialIntelligence,vol. In the dense environment, the computation cost was higher 219,pp.40–66,2015. than that in the sparse environment, and CA*-ILP was more [10] E.Boyarski,A.Felner,R.Stern,G.Sharon,O.Betzalel,D.Tolpin,and\neffective in calculating time. In all the experiments, ILP- E.Shimony,“ICBS:TheImprovedConflict-BasedSearchAlgorithm\nfor Multi-Agent Pathfinding,” in Proceedings of the International\nonly found a feasible solution within the time limit of SymposiumonCombinatorialSearch,vol.6,2015,pp.223–225.",
      "size": 881,
      "sentences": 7
    },
    {
      "id": 45,
      "content": "ct-BasedSearchAlgorithm\nfor Multi-Agent Pathfinding,” in Proceedings of the International\nonly found a feasible solution within the time limit of SymposiumonCombinatorialSearch,vol.6,2015,pp.223–225. 1200s;however,ILP-onlydidnotalwaysfindagoodfeasible [11] M.Barer,G.Sharon,R.Stern,andA.Felner,“SuboptimalVariantsof\ntheConflict-BasedSearchAlgorithmfortheMulti-AgentPathfinding\nsolution within the time limit. Consequently, the average\nProblem,”inProceedingsoftheInternationalSymposiumonCombi-\nmakespan of CA*-ILP was smaller than ILP-only. natorialSearch,vol.5,2014,pp.19–27. [12] D.Silver,“CooperativePathfinding,”inProceedingsoftheAAAICon-\nV. CONCLUSION ferenceonArtificialIntelligenceandInteractiveDigitalEntertainment,\nvol.1,2005,pp.117–122.",
      "size": 745,
      "sentences": 5
    },
    {
      "id": 46,
      "content": "alSearch,vol.5,2014,pp.19–27. [12] D.Silver,“CooperativePathfinding,”inProceedingsoftheAAAICon-\nV. CONCLUSION ferenceonArtificialIntelligenceandInteractiveDigitalEntertainment,\nvol.1,2005,pp.117–122. Inthisstudy,wedefinedtheMARPFproblemforplanning\n[13] F.Grenouilleau,W.-J.vanHoeve,andJ.N.Hooker,“AMulti-Label\nthe paths of target racks to their designated locations using A* Algorithm for Multi-Agent Pathfinding,” in Proceedings of the\nAGVsindenseenvironmentswithoutpassages.Weproposed\nInternational Conference on Automated Planning and Scheduling,\nvol.29,2021,pp.181–185. an ILP-based formulation for synchronized time-expanded\n[14] H.Ma,J.Li,T.K.S.Kumar,andS.Koenig,“LifelongMulti-Agent\nnetworksbydividingthemovementsofAGVsandracks.The PathFindingforOnlinePickupandDeliveryTasks,”inProceedings\nof the International Joint Conference on Autonomous Agents and\nproposed method optimized the paths to move the obstacles\nMultiagentSystems,2017,pp.837–845. and convey the target racks.",
      "size": 981,
      "sentences": 5
    },
    {
      "id": 47,
      "content": "”inProceedings\nof the International Joint Conference on Autonomous Agents and\nproposed method optimized the paths to move the obstacles\nMultiagentSystems,2017,pp.837–845. and convey the target racks. Based on the complexity that\n[15] J.YuandS.M.LaValle,“PlanningOptimalPathsforMultipleRobots\nincreaseswithpathlength,wealsopresentedanacceleration onGraphs,”in2013IEEEInternationalConferenceonRoboticsand\nmethod combined with CA*. Our experiments confirmed\nAutomation,2013,pp.3612–3617. [표 데이터 감지됨]",
      "size": 496,
      "sentences": 5
    }
  ]
}