{
  "source": "ArXiv",
  "filename": "051_On_Ordering_Multi-Robot_Task_Executions_within_a_C.pdf",
  "total_chars": 87172,
  "total_chunks": 127,
  "chunks": [
    {
      "id": 1,
      "content": "=== 페이지 1 ===\nA\nOn Ordering Multi-Robot Task Executions within a Cyber Physical\nSystem\nTUSHARSEMWAL,IndianInstituteofTechnologyGuwahati\nSHASHISHEKHARJHA,IndianInstituteofTechnologyGuwahati\nSHIVASHANKARB.NAIR,IndianInstituteofTechnologyGuwahati\nWithrobotsenteringtheworldofCyberPhysicalSystems(CPS),orderingtheexecutionofallocatedtasks\nduring run-time becomes crucial. This is so because, in a real world, there can be several physical tasks\nthat use shared resources that need to be executed concurrently. In this paper, we propose a mechanism\nto solve this issue of ordering task executions within a CPS which inherently handles mutual exclusion.",
      "size": 647,
      "sentences": 3
    },
    {
      "id": 2,
      "content": "e shared resources that need to be executed concurrently. In this paper, we propose a mechanism\nto solve this issue of ordering task executions within a CPS which inherently handles mutual exclusion. ThemechanismcaterstoadecentralizedanddistributedCPScomprisingnodessuchascomputers,robots\nand sensor nodes, and uses mobile software agents that knit through them to aid the execution of the\nvarioustaskswhilealsoensuringmutualexclusionofsharedresources.Thecomputations,communications\nandcontrol,areachievedthroughthesemobileagents.Physicalexecutionofthetasksisperformedbythe\nrobotsinanasynchronousandpipelinedmannerwithouttheuseofaclock.Themechanismalsofeatures\nadditionanddeletionoftasksandinsertionandremovalofrobotsfacilitatingOn-The-FlyProgramming.As\nanapplication,aWarehouseManagementSystemasaCPShasbeenimplemented.Thepaperconcludes\nwiththeresultsanddiscussionsonusingthemechanisminbothemulatedandrealworldenvironments.",
      "size": 923,
      "sentences": 3
    },
    {
      "id": 3,
      "content": "atingOn-The-FlyProgramming.As\nanapplication,aWarehouseManagementSystemasaCPShasbeenimplemented.Thepaperconcludes\nwiththeresultsanddiscussionsonusingthemechanisminbothemulatedandrealworldenvironments. CCSConcepts:•Computingmethodologies→Intelligentagents;Multi-agentsystems;Mobileagents;\nCooperationandcoordination;Distributedalgorithms;•Computersystemsorganization→Embedded\nandcyber-physicalsystems;Robotics;\nAdditionalKeyWordsandPhrases:MutualExclusion,DistributedSystems,Multi-RobotSystems(MRS). 1. INTRODUCTION\nWhile robotic applications are fast making inroads into a plethora of automated sys-\ntems, the tight coupling between the application and the robotic hardware seem to\ndeterboththeirscalabilityandflexibility.Theneedofthedayistotransformsuchau-\ntomatedsystemsintoonesthataremalleableandaccessibleoveranetwork.Through\nthistransformation,afairamountofgenericnaturecanbeembeddedwithinsuchsys-\ntems,therebyallowingforchangestobemadeinthepatternsornatureofexecutions\nof the tasks performed.",
      "size": 997,
      "sentences": 4
    },
    {
      "id": 4,
      "content": "accessibleoveranetwork.Through\nthistransformation,afairamountofgenericnaturecanbeembeddedwithinsuchsys-\ntems,therebyallowingforchangestobemadeinthepatternsornatureofexecutions\nof the tasks performed. This flexibility can be realized only if we facilitate network-\ning among all the entities within these systems. Networking can allow the entities\nto communicate with one another and resolve several issues that crop up during run\ntime. If the entities are mobile, the network becomes dynamic and makes one-to-one\ncommunication, a much disorganized task. A centralized approach for controlling the\nentitiesmayperformwellbutmakesthesystemrigid,expensiveandhardlyscalable. On the contrary, a decentralized and distributed control mechanism coupled with a\nmobilecomputingenvironmentcanempowerthesesystemswithautonomy,flexibility\nand scalability.",
      "size": 841,
      "sentences": 6
    },
    {
      "id": 5,
      "content": "expensiveandhardlyscalable. On the contrary, a decentralized and distributed control mechanism coupled with a\nmobilecomputingenvironmentcanempowerthesesystemswithautonomy,flexibility\nand scalability. Such automated scenarios can be viewed to be made up of two ba-\nsic components – a cyber component that caters to both computing and networking of\nPrimaryAuthor’saddress:TusharSemwal(t.semwal@iitg.ernet.in),DepartmentofComputerScienceand\nEngineering,IndianInstituteofTechnologyGuwahati;(Currentaddress)DepartmentofComputerScience\nandEngineering,Guwahati,Assam781039.",
      "size": 566,
      "sentences": 3
    },
    {
      "id": 6,
      "content": "ss:TusharSemwal(t.semwal@iitg.ernet.in),DepartmentofComputerScienceand\nEngineering,IndianInstituteofTechnologyGuwahati;(Currentaddress)DepartmentofComputerScience\nandEngineering,Guwahati,Assam781039. Permissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalorclassroomuseisgranted\nwithoutfeeprovidedthatcopiesarenotmadeordistributedforprofitorcommercialadvantageandthat\ncopiesbearthisnoticeandthefullcitationonthefirstpage.Copyrightsforcomponentsofthisworkowned\nbyothersthanACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepub-\nlish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/orafee.Request\npermissionsfrompermissions@acm.org. (cid:13)c YYYYACM. 1556-4665/YYYY/01-ARTA$15.00\nDOI:http://dx.doi.org/10.1145/0000000.0000000\nACMTransactionsonAutonomousandAdaptiveSystems,Vol.V,No.N,ArticleA,Publicationdate:JanuaryYYYY.",
      "size": 877,
      "sentences": 4
    },
    {
      "id": 7,
      "content": "s@acm.org. (cid:13)c YYYYACM. 1556-4665/YYYY/01-ARTA$15.00\nDOI:http://dx.doi.org/10.1145/0000000.0000000\nACMTransactionsonAutonomousandAdaptiveSystems,Vol.V,No.N,ArticleA,Publicationdate:JanuaryYYYY. 8102\nbeF\n8\n]CD.sc[\n1v18740.3081:viXra\n=== 페이지 2 ===\nAcceptedinACMTAAS Pre-printcopy\nthe entities and a set of physical processes which are executed in the real world by\na set of robots using percepts received from either on-board sensors or sensor nodes. Considering the fact that the physical processes are initiated, linked and to some ex-\ntent controlled by the cyber component, this type of a system can be categorized as a\nCyber-PhysicalSystem(CPS)[BahetiandGill2011].Hence,anetworkedMulti-Robot\nSystem (MRS) coupled with a mobile computing environment can provide a fitting\nframeworkforaCPS. Research in MRS has mostly been focused broadly on two main areas viz. task\nallocation and task partitioning.",
      "size": 907,
      "sentences": 7
    },
    {
      "id": 8,
      "content": "(MRS) coupled with a mobile computing environment can provide a fitting\nframeworkforaCPS. Research in MRS has mostly been focused broadly on two main areas viz. task\nallocation and task partitioning. In the former [Gerkey and Mataric 2001], tasks are\nassignedtotheappropriateparticipatingentities(robots)insuchawaythatadesired\nperformancelevelcanbeachievedwithcompleteutilizationofavailableresources.The\nlatter,ontheotherhand,istheprocessbywhichataskisdividedintoasetofsubtasks\nso as to reduce the complexity of its execution [Ratnieks and Anderson 1999]. Apart\nfromthese,thereisalsoathirdobjectivecrucialtoanMRSbasedCPSviz.thatoftask\nexecutionwhichisgrosslyignoredinMRSspecifications.Taskexecutionisaninherent\nobjective(usuallydefinedbytheuser)thatalwayscommencesaftertaskallocationor\npartitioning. While the allocation and partitioning are merely planning models, task\nexecution adheres to the actual implementation which validates the assignments of\nthe tasks.",
      "size": 963,
      "sentences": 6
    },
    {
      "id": 9,
      "content": "aftertaskallocationor\npartitioning. While the allocation and partitioning are merely planning models, task\nexecution adheres to the actual implementation which validates the assignments of\nthe tasks. Hence, both task allocation and task partitioning are dependent on task\nexecution without which a task cannot be said completed. Early work on Multi-Robot\nTaskAllocation(MRTA)byParker[1998]describesanarchitecturewherefaulttoler-\nancewasincorporatedinaheterogeneoussetofrobotsforcarryingoutdifferenttasks. They demonstrated dynamic task allocation (a subclass of task allocation) within an\nMRS.AformalanalysisoftheproblemsfacedinMRTAhasbeenpresentedin[Gerkey\nand Mataric 2003]. Botelho and Alami [1999] describe a technique for allocation and\nreallocationoftasks.Intheirwork,eachrobotisprovidedwithdetailsofitsownplan.",
      "size": 817,
      "sentences": 6
    },
    {
      "id": 10,
      "content": "emsfacedinMRTAhasbeenpresentedin[Gerkey\nand Mataric 2003]. Botelho and Alami [1999] describe a technique for allocation and\nreallocationoftasks.Intheirwork,eachrobotisprovidedwithdetailsofitsownplan. Arobotisallowedtomakechangesinitsplandependinguponitscapabilitiesasalso\nthoseoftheotherrobots.Theuseofauctioningtechniquesbasedondynamicsofamar-\nkethasbeenproposedbyDiasandStentz[2000],wheretherobotsareassignedtasks\nthrough negotiations with their peers in a distributed manner. Khaluf and Rammig\n[2013] narrow down the scope of task allocation to time-constrained tasks. However,\ntheyhaveignoredthecomplexitiesofreal-worldtaskexecutionandprovidedonlythe\nsimulationresults.",
      "size": 673,
      "sentences": 5
    },
    {
      "id": 11,
      "content": "ner. Khaluf and Rammig\n[2013] narrow down the scope of task allocation to time-constrained tasks. However,\ntheyhaveignoredthecomplexitiesofreal-worldtaskexecutionandprovidedonlythe\nsimulationresults. Theapproachesdiscussedsofardonotaddressthecomplexitiesinvolvedinordering\nofactualtaskexecutionsintherealworld.Orderingsuchexecutionsrequiresacareful\nunderstanding of the available resources needed to complete a task within a CPS of\nrobots.Theseresourcesmaybeeitherexclusivelyavailabletoeveryrobotortheymay\nneedtobeshared.IftheresourcesaretobesharedbytherobotswithinaCPSforthe\ncompletion of their assigned tasks, then a mechanism for mutual exclusion of shared\nresources becomes mandatory in order to avoid contentions and deadlocks. Tasks in-\nvolvingsharedresourcesarecommoninthereal-world.Forinstance,aticketcounter\nwhere people wait in a queue, is a typical example of a shared resource.",
      "size": 889,
      "sentences": 5
    },
    {
      "id": 12,
      "content": "order to avoid contentions and deadlocks. Tasks in-\nvolvingsharedresourcesarecommoninthereal-world.Forinstance,aticketcounter\nwhere people wait in a queue, is a typical example of a shared resource. In the realm\nofMRS,asolebattery-chargingterminalwhereataninstantonlyonerobotcanplug-\nin and charge itself, forms an example where mutual exclusion needs to be exercised. ThemutualexclusionprobleminanMRScanbesolvedusingcentralizedcontrol.The\ncentral controller can monitor and communicate with all the robots regarding their\nturns to gain access to all the shared resources. Though simple and straightforward,\nthis solution could drastically load the central controller with heavy computational\nand communication overheads. Further, any change in the CPS would mean bringing\ndownthecentralserver.",
      "size": 794,
      "sentences": 6
    },
    {
      "id": 13,
      "content": "ightforward,\nthis solution could drastically load the central controller with heavy computational\nand communication overheads. Further, any change in the CPS would mean bringing\ndownthecentralserver. In the domain of distributed computing, the Mutual Exclusion of shared Re-\nsources (MER)isreferredasaclassicalbenchmarkproblemtoresolveresourcecon-\n2\n=== 페이지 3 ===\nAcceptedinACMTAAS Pre-printcopy\ntentions[Raynal1986].MERisrequiredwhendifferentnodesneedtoaccessashared\nresource at the same time, lest a race condition [Raynal 1986] occur. A CPS consti-\ntuting mobile networked robots could be looked upon as a Mobile Ad-hoc Network\n(MANET).TheproblemofMERbecomesmorecomplicatedinthecontextofMANETs\n[Basagnietal.2004]whereinmobilenodesmoveinadisorganizedmannerleadingto\ndynamisminthecommunicationtopology.Inaddition,MANETsareconstrainedwith\nlimitedbandwidth,lowpowerusage,lowcomputationscapabilities,dynamictopology,\netc.",
      "size": 919,
      "sentences": 4
    },
    {
      "id": 14,
      "content": "inmobilenodesmoveinadisorganizedmannerleadingto\ndynamisminthecommunicationtopology.Inaddition,MANETsareconstrainedwith\nlimitedbandwidth,lowpowerusage,lowcomputationscapabilities,dynamictopology,\netc. [Fife and Gruenwald 2003] that increases the complexity of the MER problem as\ncomparedtotheirstaticcounterparts.SolutionstotheMERproblemindistributedand\ndynamic networks can be broadly divided into two categories [Anchal et al. 2014] —\ntokenbasedandpermissionbased.Inthetokenbasedapproach,anodewithaunique\ntoken can access the shared resources while others have to wait for the arrival of the\ntoken. On the other hand, in the permission based approach, a node can get access\nto a shared resource if it can get permissions from all other nodes in the network by\nexchanging messages. Since, in this approach, a node sends a request for getting ac-\ncessthroughmessagestoalltheconnectednodes,itconsumesbandwidthandthereby\nintroduces network latency.",
      "size": 945,
      "sentences": 5
    },
    {
      "id": 15,
      "content": "the network by\nexchanging messages. Since, in this approach, a node sends a request for getting ac-\ncessthroughmessagestoalltheconnectednodes,itconsumesbandwidthandthereby\nintroduces network latency. Although many variants of the MER problem have been\nproposed [Chandy and Misra 1984; Hadzilacos 2001; Bulgannawar and Vaidya 1995;\nAttiyaetal.2010],anadaptiveandscalablesolutionincontextofaCPS,whereinthe\nentities performing tasks need to share physical resources in the real world, has still\nnotbeenproposed.Wuetal. [2015],havemodeledtheproblemofmutualexclusionof\ntrafficintersectionsasavariantoftheclassicalmutexproblem.Vehiclescompetetoget\naccesstothetrafficintersectionbyexchangingmessages.Avehiclepassesthroughthe\nintersection when it receives permissions from other vehicles involved in the compe-\ntition.Theirapproachhowever,usesmultiplemessageswhichleadtocommunication\noverheads and network latency. Minimizing such overheads while ensuring MER is\ncrucialfortheperformanceofaCPS.",
      "size": 986,
      "sentences": 5
    },
    {
      "id": 16,
      "content": "d in the compe-\ntition.Theirapproachhowever,usesmultiplemessageswhichleadtocommunication\noverheads and network latency. Minimizing such overheads while ensuring MER is\ncrucialfortheperformanceofaCPS. Depending upon their nature, tasks can be divided into two types - (i) Independent\nand(ii)Sequential.Independenttaskscanbeexecutedinisolationandthusdonotin\nanywayrelyonothertasks.Bysequential,wemeanthatthesetasksfollowatopolog-\nical order such that a task say, T is executed only if the execution of the preceding\ni+1\ntask T is completed. In a typical computing environment, when a program includes\ni\nbothparallelandsequentiallyexecutableinstructionsormethods,theassociatedcom-\npilerseparatestheindependentonesfromthesequentialones.Basedontheprogram,\nit assigns the independent ones to individual cores within a multi-core processor to\nmaximize parallelism. The number of such cores which could be looked upon as in-\ndependent processing units, naturally do not change.",
      "size": 969,
      "sentences": 5
    },
    {
      "id": 17,
      "content": "pendent ones to individual cores within a multi-core processor to\nmaximize parallelism. The number of such cores which could be looked upon as in-\ndependent processing units, naturally do not change. On the contrary in a real world\nmulti-mobile-robot scenario where robots are synonymous to such computing cores,\nthismaynotbethecase.Thenumberofrobotsavailabletoperformasetoftasksmay\nvaryovertime.Suchvariationcouldbeduetothefactthatsomerobotsmayneedtobe\ncharged while others could have malfunctioned for some reason. Their number could\nalsoincrease,ifmorerobotsaredeployedintothescenario.Aprecompilingprocedure\ntoinitiallyallocatesequentialandindependenttaskstoasetofrobots,asinatypical\nmulti-corecomputingenvironmentcouldbedisastrous.",
      "size": 735,
      "sentences": 4
    },
    {
      "id": 18,
      "content": "alsoincrease,ifmorerobotsaredeployedintothescenario.Aprecompilingprocedure\ntoinitiallyallocatesequentialandindependenttaskstoasetofrobots,asinatypical\nmulti-corecomputingenvironmentcouldbedisastrous. Further, in the physical world, tasks could be interdependent by virtue of the fact\nthattheyrequirebothrobotsandresourcestogetexecuted.Forinstance,considerthe\ncase where robot R is to execute a task T using a resource ψ while robot R is to\n1 1 1 2\nexecutetaskT usingthesameresourceψ .Inthisscenario,assumingT andT tobe\n2 1 1 2\nindependent tasks, it can be observed that though both robots R and R are free to\n1 2\nexecutethetwotasks,thenon-availabilityofψ concurrentlytobothR andR creates\n1 1 2\na bottleneck. One of them has to wait for the other to free the resource ψ forcing T\n1 1\nand T to be executed sequentially executed. It may be noted here that, independent\n2\n3\n=== 페이지 4 ===\nAcceptedinACMTAAS Pre-printcopy\ntasks may also suffer from similar bottlenecks when they require the same resource.",
      "size": 999,
      "sentences": 4
    },
    {
      "id": 19,
      "content": "ted sequentially executed. It may be noted here that, independent\n2\n3\n=== 페이지 4 ===\nAcceptedinACMTAAS Pre-printcopy\ntasks may also suffer from similar bottlenecks when they require the same resource. Under such conditions, this resource dependency forces these independent tasks to be\nexecuted sequentially. One can thus conclude that a technique that can handle the\norderingofalltypesoftaskson-the-flywhilealsocateringandeffectivelyutilizingthe\nvaryingnumberofmobileprocessingunits,formsasinequanonforCPSscomprising\nmobilerobots. In this paper, we formulate the problem of ordering the execution of sequential,\nindependentandinterdependenttaskstobeexecutedbymultiplemobilerobotswithin\na CPS and propose a mechanism to solve the same. An agent based approach has\nbeen formulated to ensure MER among multiple robots connected to form a dynamic\nnetwork.",
      "size": 851,
      "sentences": 6
    },
    {
      "id": 20,
      "content": "cutedbymultiplemobilerobotswithin\na CPS and propose a mechanism to solve the same. An agent based approach has\nbeen formulated to ensure MER among multiple robots connected to form a dynamic\nnetwork. A sequence of topologically ordered and interdependent tasks that involves\nsharedresources,forcestheirexecutionintheformofapipeline.Sincethenumberof\nmobile robots available to execute a set of tasks could vary, we have tried to portray\nthese robots as a pipeline wherein the number of processing units could vary during\nrun-time.Aconventionalpipelinedcomputingarchitecturerequiresaclockinorderto\nsynchronizeandallocatepropertimeslotsfortheexecutionofprocesses.Theexecution\ntimesforthevarioustasksperformedbyasetofrobotshowever,varyovertimedueto\nseveralreal-worldproblems.Ifapipelineneedstocatertosuchvaryingtimesrequired\nfortheexecutions,itshouldpossessaninherentlyadaptiveclockingmechanismsoas\ntocompensateforsuchvariations.",
      "size": 925,
      "sentences": 3
    },
    {
      "id": 21,
      "content": ",varyovertimedueto\nseveralreal-worldproblems.Ifapipelineneedstocatertosuchvaryingtimesrequired\nfortheexecutions,itshouldpossessaninherentlyadaptiveclockingmechanismsoas\ntocompensateforsuchvariations. The algorithm proposed in this paper is novel in the sense that: 1) In this work,\nwe have used intelligent messages in the form of mobile agents to solve the problem\nof mutual exclusion while executing tasks in a multi-robot distributed environment. Conventional distributed scenarios as in Wu et al. [2015], use message broadcasts to\nshare information and ensure mutual exclusion of shared resources. Message broad-\ncasting drastically increases the communication cost [Wu et al. 2015] and can clutter\nanetwork.Intheproposedmechanism,wehaveusedaconscientiousagentmigration\nstrategy [Minar et al. 1999] which has least inter-node communication cost [Godfrey\net al.2013] ascompared to otheragent basedapproaches suchas CLInG [Sempeand\nDrogoul 2003], EVAP [Chu et al.",
      "size": 965,
      "sentences": 7
    },
    {
      "id": 22,
      "content": "gration\nstrategy [Minar et al. 1999] which has least inter-node communication cost [Godfrey\net al.2013] ascompared to otheragent basedapproaches suchas CLInG [Sempeand\nDrogoul 2003], EVAP [Chu et al. 2007] and Random-walk with cloning [Gaber and\nBakhouya2008].2)Synchronizationindistributedsettingsisamajorchallengeandis\ntraditionally achieved by using a single node (or a subset of nodes) which provide for\nclocking.Thisposesissuesofreliabilitywhensuchnodesfail.Inthedomainofrobotics,\ntheproblemofsynchronizationdeterioratessincethetimerequiredtoexecuteagiven\ntaskbyarobotcanvaryduetoseveralenvironmentalfactors.Inthemechanismpro-\nposed herein, the agents ensure an inherent adaptive clocking mechanism to achieve\nsynchronizationacrossthenetworkofrobots.Inaddition,featuressuchasconcurrent\nexecutionoftasks,on-the-flyadditionanddeletionoftasksandinclusionandremoval\nofrobots,emphasizetheflexibilityandversatilityoftheproposedmechanism.Finally,\naWarehouseManagementSystem(WMS)asanapplicationhasbeenimplementedto\ndemonstratethefeasibilityofourapproach.",
      "size": 1051,
      "sentences": 3
    },
    {
      "id": 23,
      "content": "sionandremoval\nofrobots,emphasizetheflexibilityandversatilityoftheproposedmechanism.Finally,\naWarehouseManagementSystem(WMS)asanapplicationhasbeenimplementedto\ndemonstratethefeasibilityofourapproach. In brief, our major contributions towards the Task Execution Ordering Problem\n(TEOP)are-\n(1) A mobile agent based distributed mechanism for ordering multi-robot task execu-\ntions. (2) AsolutionfortheMERproblemamongmultiplerobotswithinaCPS. (3) Validationoftheproposedmechanismthroughemulation. (4) Real world implementation of the proposed mechanism with WMS as an applica-\ntion. Theremainingpartofpaperisorganizedasfollows:Section2discussesagentbased\nsystems and their applications. Section 3 describes the constituents and system spec-\n4\n=== 페이지 5 ===\nAcceptedinACMTAAS Pre-printcopy\nifications of the proposed CPS.",
      "size": 817,
      "sentences": 7
    },
    {
      "id": 24,
      "content": "llows:Section2discussesagentbased\nsystems and their applications. Section 3 describes the constituents and system spec-\n4\n=== 페이지 5 ===\nAcceptedinACMTAAS Pre-printcopy\nifications of the proposed CPS. The Task Execution Ordering Problem (TEOP) among\nmultiplerobotsandtheinherentobjectivesforrealizingtheCPSarediscussedinSec-\ntion 4 while the proposed mechanism is described in Section 5. Section 6 describes a\nreal-world implementation of the proposed mechanism while Section 7 presents the\nresultsobtainedinboththeemulatedandreal-worldscenarios.Finally,Section8con-\ncludesthepaperandprovidesdirectionsforfuturework. 2. AGENTBASEDSYSTEMS\nAn agent is as an intelligent software code that has a certain degree of autonomy\n[FranklinandGraesser1997].Agentsaresmartbeingsthatresideinthecyberworld\nand carry out tasks or computations on behalf of the users. As human beings in the\nreal-world, agents form their counterpart in the cyber world.",
      "size": 935,
      "sentences": 7
    },
    {
      "id": 25,
      "content": "ser1997].Agentsaresmartbeingsthatresideinthecyberworld\nand carry out tasks or computations on behalf of the users. As human beings in the\nreal-world, agents form their counterpart in the cyber world. They are autonomous,\ndecisive, flexible, adaptive, reactive, pro-active, social, have locality of reference and\nmanyotherfeatures[Schumacher2001].Agentscanbebroadlydividedintotwotypes\n— static agents and mobile agents. Usually agents are stationary entities which oc-\ncupy a fixed location within a networked environment. Mobile agents on the contrary\naredistinguishedbytheirmobilitywhichallowthemtomovefreelywithinanetwork\nof nodes. Since, mobile agents form an important component of the proposed mecha-\nnismforexecutingandorderingofasequenceofinterdependenttaskswithinaCPSof\nmultiplerobots,thesucceedingsectionpresentsabriefbackgroundontheuseofthese\nagents. 2.1.",
      "size": 865,
      "sentences": 7
    },
    {
      "id": 26,
      "content": "ortant component of the proposed mecha-\nnismforexecutingandorderingofasequenceofinterdependenttaskswithinaCPSof\nmultiplerobots,thesucceedingsectionpresentsabriefbackgroundontheuseofthese\nagents. 2.1. MobileAgents\nAsmentioned,amobileagentisaprogramthatcanmigratefromonenodetoanother\nwithin a network and can perform autonomous computations. Along with mobility,\nthese agents also possess other abilities such as cloning, autonomy, payload carry-\ningcapability,on-nodeexecution,localdecisionmaking,adaptability,etc. [Outtagarts\n2009]. Mobile agents have been used in a myriad of applications ranging from wire-\nless sensor networks [Chen et al. 2007], e-commerce [Maes et al. 1999], robot control\n[Kambayashi et al. 2005; Godfrey and Nair 2008], security [Boukerche et al. 2007]\nand e-learning [Zaiane 2002]. Posadas et al. [2008] highlight the advantages of using\nmobile agents for controlling mobile robots using two approaches of executing tasks.",
      "size": 947,
      "sentences": 12
    },
    {
      "id": 27,
      "content": "rity [Boukerche et al. 2007]\nand e-learning [Zaiane 2002]. Posadas et al. [2008] highlight the advantages of using\nmobile agents for controlling mobile robots using two approaches of executing tasks. In the first approach, all the mobile robots communicate with a central server to get\nthe necessary actions which aid in the completion of a set of tasks. In the second, the\nmobileagentsarereleasedintothenetworkofmobilerobots.Thesearethenmadeto\nexecute programs locally on each mobile robot based on their local decision making\ncapabilities. The authors report that the latter approach is more effective in terms of\ntime required to execute an action by a mobile robot when compared to the former\ncentralized method. This is so because considerable time is wasted in communication\nwiththecentralserver. GodfreyandNair[2012]describehowmobileagentscanbeusedtoprovideservices\nin an MRS. They also compare the performance of mobile agent migration strategies.",
      "size": 955,
      "sentences": 10
    },
    {
      "id": 28,
      "content": "wasted in communication\nwiththecentralserver. GodfreyandNair[2012]describehowmobileagentscanbeusedtoprovideservices\nin an MRS. They also compare the performance of mobile agent migration strategies. Some of the important reasons for the use of mobile agents for the realization of dis-\ntributedsystemsare[Cruz-Cunha2011]—\n(1) Network traffic and latency reduction: Mobile agents perform computations and\ninteractionslocallyatanode.Thisresultsinfasterresponseandavoidsexcessive\nmessagepassing. (2) Adaptationandcustomization:Intraditionaldistributedsystems,astheprotocols\nevolve for transmitting and interpreting the outgoing and incoming data respec-\ntively,itbecomescumbersometoupdatetheserversandcreatesalegacyproblem\n5\n=== 페이지 6 ===\nAcceptedinACMTAAS Pre-printcopy\n[Lange1998].Insuchscenarios,mobileagentsprovideforflexibilityasclientscan\ndispatchthemtotheserverforestablishingtheamendmentstotheprotocols.",
      "size": 908,
      "sentences": 5
    },
    {
      "id": 29,
      "content": "acyproblem\n5\n=== 페이지 6 ===\nAcceptedinACMTAAS Pre-printcopy\n[Lange1998].Insuchscenarios,mobileagentsprovideforflexibilityasclientscan\ndispatchthemtotheserverforestablishingtheamendmentstotheprotocols. (3) Robustnessandfaulttolerance:Indynamicanddistributednetworks,itisimprac-\ntical to continuously maintain static communication links among the nodes. In\nsuch cases, the tasks required to be executed can be embedded within the mobile\nagents. These agents can then be dispatched into such dynamic networks. After\nbeingdispatched,theseagentsbecomeindependentandoperateautonomouslyby\ncarryingoutexecutionsatthedesignatednodesinthenetwork.Theresultscanbe\naccumulatedlaterbyreconnectingwiththeseagents. Mobile agents thus can serve as an effective tool for realizing distributed mecha-\nnismsoveranetworkofnodes. 2.2. MobileAgentFramework\nA mobile agent framework is an execution environment or a platform which provides\nsupport for agent development, programming and deployment within a network.",
      "size": 990,
      "sentences": 8
    },
    {
      "id": 30,
      "content": "networkofnodes. 2.2. MobileAgentFramework\nA mobile agent framework is an execution environment or a platform which provides\nsupport for agent development, programming and deployment within a network. It\nprovides tools for the users to create and manage agents and their behaviours. The\nagents(staticandmobile)aremanagedbytheframeworkinordertoensuretheirsuc-\ncessfulexecutionandoperation.Therearevariousmobileagentframeworksavailable\ninavarietyofprogramminglanguagessuchasJava,C/C++orProlog.JADE[Bellifem-\nine et al. 2001], a Java based agent framework, is known for its simple development\nprocessalongwithFIPA2000compliance.Mobile-C[Mostinckxetal.2009]isapurely\nC/C++ based agent framework which, due to its small code size, readily supports em-\nbedded devices. JINNI [Tarau 1999], Typhon [Matani and Nair 2011] and Tartarus\n[Semwal et al. 2015; Semwal et al.",
      "size": 859,
      "sentences": 8
    },
    {
      "id": 31,
      "content": "y\nC/C++ based agent framework which, due to its small code size, readily supports em-\nbedded devices. JINNI [Tarau 1999], Typhon [Matani and Nair 2011] and Tartarus\n[Semwal et al. 2015; Semwal et al. 2016], being Prolog based frameworks, facilitate\nrapidprototypedevelopment.TheworkreportedhereinusesTartarus,amobileagent\nframeworkforthedevelopmentandmanagementofstaticandmobileagents.Wehave\nchosenTartarusasitsupportsrapidprototyping,multi-threadedexecutionandfaster\nmobility. In addition, it comes with a pre-installed plug-in channel which allows for\nthecontrolandinteractionwithotherembeddeddevicesandsensors. 3. PRELIMINARIES\nThis section presents the entities and characteristics that make up the CPS used\nherein followed by a formal description of the problem at hand. Further, we discuss\nthemechanismstoensureMERwhenthetaskswithinaCPSneedtobeexecutedina\nsequential manner. The manner in which the tasks can be altered, added or removed\non-the-flyin/fromthesequenceisalsobeillustrated. 3.1.",
      "size": 997,
      "sentences": 10
    },
    {
      "id": 32,
      "content": "emechanismstoensureMERwhenthetaskswithinaCPSneedtobeexecutedina\nsequential manner. The manner in which the tasks can be altered, added or removed\non-the-flyin/fromthesequenceisalsobeillustrated. 3.1. ConstituentsoftheproposedCPS\nACPSisanamalgamofboththecyberandthephysicalworldswherethetermcyber\ncomprises computations, communications and control while the term physical com-\nprises interactions with the real world [Shi et al. 2011]. Our proposed CPS is com-\nposed of heterogeneous entities such as a Multi-Robot System (MRS), mobile agents,\nsensors and computer nodes. Mobile agents form the cyber entities which carry out\ncomputations,managesallthecommunicationsandcontrolthedynamicsoftheMRS. Theinteractionofrobotswiththeexternalsurroundingswhererobotsexecutethese-\nquential tasks forms the physical component.",
      "size": 814,
      "sentences": 8
    },
    {
      "id": 33,
      "content": "carry out\ncomputations,managesallthecommunicationsandcontrolthedynamicsoftheMRS. Theinteractionofrobotswiththeexternalsurroundingswhererobotsexecutethese-\nquential tasks forms the physical component. Following are the basic constituents of\ntheproposedCPSunderconsideration:\n(1) Nodes: A node refers to any device that is capable of computations and communi-\ncations and hosts an agent framework. It can be an embedded system, a personal\ncomputer,arobotorevenasensornode.Nodesareconnectedtoeachothertoform\nanetworkW. 6\n=== 페이지 7 ===\nAcceptedinACMTAAS Pre-printcopy\n(2) Network: A network W is a dynamic wireless Mobile Ad-hoc Network (MANET)\nwhereinanodecanconnectordisconnecttoanothernodeatanypointoftime.The\nconnectionsareinherentlymanagedbythenodeswithinthenetworkusinganyof\ntheavailablemechanisms[DhenakaranandParvathavarthini2013].",
      "size": 835,
      "sentences": 5
    },
    {
      "id": 34,
      "content": "NET)\nwhereinanodecanconnectordisconnecttoanothernodeatanypointoftime.The\nconnectionsareinherentlymanagedbythenodeswithinthenetworkusinganyof\ntheavailablemechanisms[DhenakaranandParvathavarthini2013]. (3) Robots: A set of networked robots R ={R ,R ,R ,...,R |k ≥ 1} all of which hosts\n1 2 3 k\nan agent platform within and can connect to the network W in an ad-hoc man-\nner. These are essentially a subset of nodes responsible for the execution of tasks. Robots are mobile and are equipped with sensors and actuators that enable them\ntosensetheirenvironmentandactuponthem,respectively. (4) Tasks:AsetoffinitetasksT ={T ,T ,T ,...,T |n≥1},capableofbeingexecuted\n1 2 3 n\nbythesetofrobotsR. (5) Resources:Utilitiesandnodesotherthanrobots,suchasapath,parking/charging\nbays, a rack containing items which can act as a node, sensor nodes, etc., in the\nMRS environment required by a robot to accomplish a task, constitute a set of\nresources ψ = {ψ , ψ , ψ ,...,ψ |r ≥ 1}.",
      "size": 962,
      "sentences": 6
    },
    {
      "id": 35,
      "content": "ays, a rack containing items which can act as a node, sensor nodes, etc., in the\nMRS environment required by a robot to accomplish a task, constitute a set of\nresources ψ = {ψ , ψ , ψ ,...,ψ |r ≥ 1}. Resources need to be shared amongst\n1 2 3 r\nrobots in the set R while a robot executes the tasks in T. Once a robot takes over\na resource(s), it becomes non-shareable before it is freed by the robot. For clarity,\ntwoformsofconventionshavebeenfollowedinthispaperviz.ψ andψi,wherefor\ni\nthetaskT ,ψ isaparticularresourcefromthesetψ whileψi ⊆ψ. i i\n(6) States:Statespertaintorobots.STj indicatesthatarobotisinstateS andrequires\ni i\ntoexecutethetaskT .AllfreerobotsremaininthestatedesignatedasS∗. j 1\n(7) Agents:Asetofmobileagentsµ={µ ,µ ,µ ,...,µ |m≥1},suchthateachmobile\n1 2 2 m\nagent µ ∈ µ, carries the programs of its associated tasks as its payload.",
      "size": 849,
      "sentences": 5
    },
    {
      "id": 36,
      "content": "freerobotsremaininthestatedesignatedasS∗. j 1\n(7) Agents:Asetofmobileagentsµ={µ ,µ ,µ ,...,µ |m≥1},suchthateachmobile\n1 2 2 m\nagent µ ∈ µ, carries the programs of its associated tasks as its payload. It may\ni\nbe noted that each agent carries the programs for a set of task(s) assigned to it\nalong with the information of the required set of associated resources. An agent\nalsocarrieswithittheStateInformation(SI)intheformofSTj oftherobotswhich\ni\nitcanserve,andthenextstatetowhichtherobotstransitafterexecutionofT . j\n(8) Job:AJobJ isacollectionoftasksinT alongwiththeassociatedsetofresources\ni\ninψ,whicharerequiredtobeexecutedbytherobotsinRandconstitutethebasic\ninputstothesystem.Here,J ⊆{(Ti,ψ1),(Ti,ψ2),..,(Ti,ψn)},Ti isthenth taskofjob\ni 1 2 n n\nJ and ψn ⊆ ψ. The intersection of subsets of the type ψn need not be a null set\ni\nindicating that a particular set of resources could be required by more than one\ntask.ThesejobsareprocessedandpackedintomobileagentsbyaJobDistributor\nJ .",
      "size": 984,
      "sentences": 6
    },
    {
      "id": 37,
      "content": "bsets of the type ψn need not be a null set\ni\nindicating that a particular set of resources could be required by more than one\ntask.ThesejobsareprocessedandpackedintomobileagentsbyaJobDistributor\nJ . New jobs received by the J could commence their execution even when\nDist Dist\ntheirpredecessorsarebeingexecuted. Herek,n,randm∈IwhereIisasetofpositiveintegers. 3.2. SystemSpecifications\nFor a better insight into the complexity of the proposed CPS, the specifications and\nbehavior of the system need to be defined precisely. Listed below are some pertinent\npointsaboutthesystem—\n(1) ThenumberofnodesinthenetworkW isfinite. (2) AnynodecanconnectordisconnectfromthenetworkW atanyinstantoftime. (3) The system is completely oblivious of the total number of robots R present in the\nnetworkW atanypointoftime. (4) ThenumberofmobileagentsµinhabitingthenetworkW variesdynamicallywith\nthechangeinthesequenceoftasks. (5) ThesequenceinwhichthetasksinthesetT needtobeexecutedmaybechanged\naspertherequirements.",
      "size": 997,
      "sentences": 10
    },
    {
      "id": 38,
      "content": "time. (4) ThenumberofmobileagentsµinhabitingthenetworkW variesdynamicallywith\nthechangeinthesequenceoftasks. (5) ThesequenceinwhichthetasksinthesetT needtobeexecutedmaybechanged\naspertherequirements. 7\n=== 페이지 8 ===\nAcceptedinACMTAAS Pre-printcopy\nFig. 1: Graph depicting the inherent sequential and interdependent nature of execu-\ntionoftasks\n(6) Eachoftherobotsandtheagentsareautonomousentitiescapableofcarryingout\nindependentexecutions. (7) Thereisnodirectrobot-to-robotoragent-to-agentcommunication. 4. THETASKEXECUTIONORDERINGPROBLEM(TEOP)\nConsider a CPS with a finite number of homogeneous robots. Each robot is required\nto carry out the execution of a finite number of tasks that are interdependent. Since\nall the robots are required to execute such tasks, a robot may need a set of resources\nwhicharesharedamongitspeers.Thisinvokesthenecessityforthemutualexclusion\nof these resources while executing the tasks.",
      "size": 918,
      "sentences": 10
    },
    {
      "id": 39,
      "content": "e robots are required to execute such tasks, a robot may need a set of resources\nwhicharesharedamongitspeers.Thisinvokesthenecessityforthemutualexclusion\nof these resources while executing the tasks. As discussed earlier, in the real world\nthenumberofrobotsavailablefortaskexecutionmayvarywithtime.Inaddition,one\nmay need to alter, add or delete tasks on-the-fly. Under such circumstances, ordering\nthe task executions on-the-fly, becomes a challenging problem. We have modeled this\nproblemasaTaskExecutionOrderingProblem(TEOP)andproposedasolutiontothe\nsameusingasetofmobileagents. For simplicity, consider a straightforward scenario where each task T requires a\ni\nsingle resource ψ . The scenario can be easily extended to more complex ones where\ni\ninstead of a single resource, a task may require a set of resource ψi which may be\ncommon with those of other tasks.",
      "size": 866,
      "sentences": 6
    },
    {
      "id": 40,
      "content": "ngle resource ψ . The scenario can be easily extended to more complex ones where\ni\ninstead of a single resource, a task may require a set of resource ψi which may be\ncommon with those of other tasks. Figure 1 represents the problem in the form of a\ndirectedacyclicgraph.EachnodeofthegraphrepresentsarobotR performingatask\ni\nT usingtheresourcesinψ withthehelpofamobileagentµ .Additionally,thereare\ni i i\nsome nodes which represent the operator - AND (.). This operator makes sure that a\ncertain robot can perform a task T if and only if the previous dependent task T\ni i−1\nis completed (the sequential execution constraint). Since mobile agents carry the pro-\n8\n=== 페이지 9 ===\nAcceptedinACMTAAS Pre-printcopy\ngrams of the corresponding tasks, this translates the actual dependency of execution\nonto these agents.",
      "size": 810,
      "sentences": 5
    },
    {
      "id": 41,
      "content": "constraint). Since mobile agents carry the pro-\n8\n=== 페이지 9 ===\nAcceptedinACMTAAS Pre-printcopy\ngrams of the corresponding tasks, this translates the actual dependency of execution\nonto these agents. Hence, if a robot R is vying for resources to execute a task T , the\nj i\nmobileagentµ carryingtheprogramforthetaskT mustbefreeandavailableinthe\ni i\nnetwork.Byfree,wemeanthatthemobileagentshouldnotberesidentwithinarobot\nnoraidingtheexecutionoftheassociatedtask. ThegraphshownintheFigure1depictsthemannerinwhichtherobotsexecutethe\ntaskswhilealsoensuringmutualexclusion.Itmaybenotedthatallthenodeshaving\nthe same colour correspond to the same robot. Thus only one of these same-coloured\nnodescanbeactiveatanymomentoftime.Forinstance,theredcolourednodesstand\nfor the robot R . The tasks T , T and T thus cannot be executed concurrently since\n2 1 2 3\ntheyallneedtobeexecutedbythesamerobotviz.R .",
      "size": 890,
      "sentences": 6
    },
    {
      "id": 42,
      "content": "nbeactiveatanymomentoftime.Forinstance,theredcolourednodesstand\nfor the robot R . The tasks T , T and T thus cannot be executed concurrently since\n2 1 2 3\ntheyallneedtobeexecutedbythesamerobotviz.R . 2\nAsanexplanatoryexample,considerthenode(R ,µ (T ,ψ ))denotingexecutionof\n2 2 2 2\ntaskT byrobotR usingresourceψ andmobileagentµ .Inordertotraversetothis\n2 2 2 2\nnode, both inputs to the AND node viz. (R ,µ (T ,ψ )) and (R ,µ (T ,ψ )) need to be\n1 2 2 2 2 1 1 1\nTRUE i.e. R should have executed task T using µ and ψ and R should have exe-\n1 2 2 2 2\ncutedT usingµ andψ .Thisindicatesthesequentialnatureofexecutionoftasksby\n1 1 1\nR viz. (R ,µ (T ,ψ )) → (R ,µ (T ,ψ )).",
      "size": 666,
      "sentences": 6
    },
    {
      "id": 43,
      "content": ".e. R should have executed task T using µ and ψ and R should have exe-\n1 2 2 2 2\ncutedT usingµ andψ .Thisindicatesthesequentialnatureofexecutionoftasksby\n1 1 1\nR viz. (R ,µ (T ,ψ )) → (R ,µ (T ,ψ )). Additionally, the interdependency between\n2 2 1 1 1 2 2 2 2\n(R ,µ (T ,ψ )) and its predecessor nodes (R ,µ (T ,ψ )) and (R ,µ (T ,ψ )) can also\n2 2 2 2 1 2 2 2 2 1 1 1\nbeobserved.ThismeansthatT (carriedonlybyagentµ ),whichrequiresresourceψ\n2 2 2\nforexecution,cannotbeexecutedbymultiplerobotsatthesametimetherebyensuring\nmutualexclusion. 4.1. TheInherentObjectives\nWithseveralrobotsandsharedresources,orderingtheexecutionsofsequential,inde-\npendentandinterdependenttasks,becomesacomplextaskespeciallywhenthenum-\nberofexecutingrobotsandtasksvaryatrun-time.Thissectiondiscussesthisproblem\noforderingintermsofitssegregatedobjectives. Objective 1.",
      "size": 842,
      "sentences": 7
    },
    {
      "id": 44,
      "content": "dentandinterdependenttasks,becomesacomplextaskespeciallywhenthenum-\nberofexecutingrobotsandtasksvaryatrun-time.Thissectiondiscussesthisproblem\noforderingintermsofitssegregatedobjectives. Objective 1. The main objective of the work presented in this paper is to honour\nthe mutual exclusion of the use of resources ψ by the robots in R while executing all\nthetasksinthesetT.LetRj,t beabinaryfunctionthatreturns1duringthetimeslot\ni\nwhentherobotR hasacquiredresourceψ .Hencetheobjectiveis\ni j\n∀R ∈R,execute(R ,T)\ni i\nsubjectto\nn\n(cid:88)\n∀ψ ∈ψ, Rj,t ≤1 (1)\nj i\ni=1\nRj,t ∈{0,1},∀i,j\ni\natanytimeinstantt. Here, execute(R , T) denotes that the robot R ∈ R executes the tasks in the set T. As\ni i\ncan be observed from Equation 1, the constraint of the objective function essentially\ndenotestheMERamongsttherobotssuchthatnomorethanonerobotcanacquirethe\nsameresourceatanygiventime. The Objective 1 essentially makes the robots in R to align their executions in the\nform of a pipeline.",
      "size": 974,
      "sentences": 5
    },
    {
      "id": 45,
      "content": "denotestheMERamongsttherobotssuchthatnomorethanonerobotcanacquirethe\nsameresourceatanygiventime. The Objective 1 essentially makes the robots in R to align their executions in the\nform of a pipeline. Pipelining [Null and Lobur 2014] is extensively used by the com-\nputer processors in order to increase throughput. It facilitates the execution of the\nseveral of instructions in a single unit of time. For instance, the three main subtasks\nperformedbyprocessorstocompletetheexecutionofaninstructionare–Fetch,Decode\nand Execute [Null and Lobur 2014]. In the absence of a pipeline, the processor has to\nfinishthefirstinstructionwhichitreceivedfromthememoryandthenmovetowards\n9\n=== 페이지 10 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.",
      "size": 725,
      "sentences": 6
    },
    {
      "id": 46,
      "content": "[Null and Lobur 2014]. In the absence of a pipeline, the processor has to\nfinishthefirstinstructionwhichitreceivedfromthememoryandthenmovetowards\n9\n=== 페이지 10 ===\nAcceptedinACMTAAS Pre-printcopy\nFig. 2: Pipelined execution of a set of sequential and interdependent tasks having\nsharedresourcesintheproposedCPSwheredifferentcoloursindicatesdifferentrobots\nthenextinstructionsequentially.Thismakestheotherfunctionalunitsoftheproces-\nsor such as the ALU to idle while the Fetch instruction is being performed. However,\ninapipelinedarchitecture,whentheprocessorisbusyexecutinganinstruction,other\nunits within, can perform other subtasks concurrently. However, these subtasks need\ntobesynchronizedbyacommonclock.Anyincreaseordecrease(addition/deletion)in\nthe number of subtasks can cause asynchronism. This gives rise to our second objec-\ntive. Objective 2.",
      "size": 852,
      "sentences": 7
    },
    {
      "id": 47,
      "content": "r, these subtasks need\ntobesynchronizedbyacommonclock.Anyincreaseordecrease(addition/deletion)in\nthe number of subtasks can cause asynchronism. This gives rise to our second objec-\ntive. Objective 2. The second objective is concerned with maintaining the time period of\neachstageintheasynchronousroboticpipeline.Apipelineinthecontextofprocessors\ncomprises a set of cascaded tightly coupled processing elements. The output of one is\ngivenasinputtothenext.Theseelementsaredrivensynchronouslybyaclockwhose\ntime period is set to a value greater than the maximum delay incurred between the\nelements in the pipeline. Finding this maximum time delay and setting the clock ac-\ncordingly is possible in the domain of a computing system as the execution and delay\ntimesoncefixed,neverchange.However,inrealworldroboticscenarios,thesetimings\ndependonthetaskathandandtheconditionsandpositionorlocationoftherobot.In\nother words, the time to execute a task could vary temporally.",
      "size": 964,
      "sentences": 6
    },
    {
      "id": 48,
      "content": "xed,neverchange.However,inrealworldroboticscenarios,thesetimings\ndependonthetaskathandandtheconditionsandpositionorlocationoftherobot.In\nother words, the time to execute a task could vary temporally. This adds another di-\nmensionofcomplexitysincetheasynchronouslyexecutedtaskswhoseexecutiontimes\nvary, could cause problems when the robot(s) try to access a shared resource. Under\nsuch conditions the use of a synchronous lock whose time period is set to a constant\nvalue a priori could prove to be disastrous. It may be noted that when n robots are\nexecutingntasks,eachwithdistinctresourcesconcurrently,theroboticpipelineisfull\nandoperatingatitsmaximum,thussatisfyingthefollowingoptimalitycriteria–\nr k\n(cid:88)(cid:88)\n∀ψ ∈ψ, Rj,t =r (2)\nj i\nj=1i=1\natanytimeinstantt. Objective 3. The final objective of our work is to facilitate the concept of on-the-fly\nordering.",
      "size": 866,
      "sentences": 6
    },
    {
      "id": 49,
      "content": "thefollowingoptimalitycriteria–\nr k\n(cid:88)(cid:88)\n∀ψ ∈ψ, Rj,t =r (2)\nj i\nj=1i=1\natanytimeinstantt. Objective 3. The final objective of our work is to facilitate the concept of on-the-fly\nordering. In our proposed CPS scenario, one may require to modify, add (insert) or\ndelete tasks in/from the set T on-the-fly while the robots are executing tasks in the\ncurrentsetT.Further,itmayhappenthattherobotsthemselves,whichareanalogous\n10\n=== 페이지 11 ===\nAcceptedinACMTAAS Pre-printcopy\ntotheprocessingelementsinapipeline,needtobeinsertedorremovedduetofailures,\nlowbatteriesetc.Hence,providingsuchflexibilitiestotheendusersofsuchasystem\nisofvitalimportance. Taking all these challenges into consideration, we have converted the graph in\nFigure 1 into a pipeline model as depicted in Figure 2. The vertical axis in herein\nrepresents the robots in action while the horizontal one represents the time slots\nwhen the robot R uses the resource ψ in order to accomplish task T .",
      "size": 967,
      "sentences": 6
    },
    {
      "id": 50,
      "content": "picted in Figure 2. The vertical axis in herein\nrepresents the robots in action while the horizontal one represents the time slots\nwhen the robot R uses the resource ψ in order to accomplish task T . In addition,\nn n n\nP ,P ,P ,..,P denotes pipelines formed at time slots 1, 2, 3,...,n respectively. As dis-\n1 2 3 n\ncussed earlier, it can be seen that in time slot 2, the program carried by µ facilitates\n2\nR toexecuteT usingtheresourceψ .Concurrently,R executesT usingtheprogram\n1 2 2 2 1\ninµ andtheassociatedresourceψ .Bothµ andµ remainresidentontherespective\n1 1 1 2\nrobots R and R until the tasks are accomplished and thus are not available to any\n2 1\nother robot during slot 2, thus ensuring mutual exclusion among the robots.",
      "size": 731,
      "sentences": 4
    },
    {
      "id": 51,
      "content": "remainresidentontherespective\n1 1 1 2\nrobots R and R until the tasks are accomplished and thus are not available to any\n2 1\nother robot during slot 2, thus ensuring mutual exclusion among the robots. It may\nalsobenotedthatR executesT whoseprogramiscarriedbyµ usingψ intimeslot\n1 3 3 3\n3 only after R and R both have executed T and T respectively as shown in Fig-\n1 2 2 1\nure1.Itcanbeseenthatinthenth timeslot,thepipelinebecomesfullwithallrobots\nR , R ,..., R in states S , S , S ,..., S(cid:63) executing the allocated tasks T , T ,\n1 2 n n n−1 n−2 1 n n−1\nT ,...,T usingtheassociatedresourcesψ ,ψ ,ψ ,...,ψ respectivelywithout\nn−2 1 n n−1 n−2 1\nanycontention.Itmaybenotedthattheseassociatedresourcescouldbesubsetsofψ,\nnamelyψn,ψn−1,ψn−2,...,ψ1. Inthenextsection,wepresentthemechanismtoachievetheobjectiveslistedabove. 5.",
      "size": 821,
      "sentences": 4
    },
    {
      "id": 52,
      "content": "thout\nn−2 1 n n−1 n−2 1\nanycontention.Itmaybenotedthattheseassociatedresourcescouldbesubsetsofψ,\nnamelyψn,ψn−1,ψn−2,...,ψ1. Inthenextsection,wepresentthemechanismtoachievetheobjectiveslistedabove. 5. THEPROPOSEDMECHANISM\nIntheCPSscenariousedherein,therobotsinitiallyresideatabayordockingstation\nandtheirstatesareinitializedtoS(cid:63).ThissignifiesthatalltherobotsinRarecurrently\n1\nvyingtoexecutetheassociatedtaskviz.T .Asmentionedearlier,everyrobothostsan\n1\nagentframeworkthatallowstheseagentstoknitthroughthem. In addition, all the mobile agents in µ are also released into the network W by\nthe Job Distributor J . Task ordering among the jobs is highly dependent on how\nDist\nthe J assigns tasks and their associated resources to the agents. Thus, a separate\nDist\nsectionisprovidedforitsdiscussionalongwithanunderlyingalgorithm. 5.1.",
      "size": 835,
      "sentences": 8
    },
    {
      "id": 53,
      "content": "the jobs is highly dependent on how\nDist\nthe J assigns tasks and their associated resources to the agents. Thus, a separate\nDist\nsectionisprovidedforitsdiscussionalongwithanunderlyingalgorithm. 5.1. JobDistributor\nThe Job Distributor J assigns the various subsets ({T ,ψi}) within a job to\nDist i\ncorresponding agents along with the information on the associated set of resources\nrequired to execute the tasks. It also embeds the State Information (SI) of the\nrobots it can serve together with next state to which the robots need to transit. Further, the J also maintains a list of already assigned resources so that the\nDist\nsame resource is not assigned to other agents. An agent returns to the J when\nDist\nthe assigned task(s) has been executed thereby relinquishing the associated re-\nsources. In the example graph shown in Figure 1, a simple scenario was chosen\nwhere a task requires only a single resource.",
      "size": 912,
      "sentences": 8
    },
    {
      "id": 54,
      "content": "assigned task(s) has been executed thereby relinquishing the associated re-\nsources. In the example graph shown in Figure 1, a simple scenario was chosen\nwhere a task requires only a single resource. But in a real world, it is natural to\nhave tasks that require multiple resources which may need to be shared with other\ntasks. Further, the tasks within a job could be sequential or independent. The task\nassignmentstrategiesfollowedbytheJ fordifferentscenariosaredescribedbelow:\nDist\nA. Only sequential tasks – Consider a warehouse scenario wherein an item has\nto be first fetched from a rack, carried to a packing station and finally packed and\nshipped to its desired destination.",
      "size": 681,
      "sentences": 6
    },
    {
      "id": 55,
      "content": "t\nA. Only sequential tasks – Consider a warehouse scenario wherein an item has\nto be first fetched from a rack, carried to a packing station and finally packed and\nshipped to its desired destination. This job comprises a total of 3 sequential tasks -\nFetching(T ),Carrying(T )andPacking(T ),allofwhicharesequentialinnature.For\n1 2 3\ncases when these tasks use different resources, the J assigns a distinct agent for\nDist\neachtasktogetherwiththeassociatedsetofresources.ThusT andψi,areembedded\n1\n11\n=== 페이지 12 ===\nAcceptedinACMTAAS Pre-printcopy\nALGORITHM1:SequenceofstepsfollowedbytheJobDistributorJ\nDist\n1: Input:AJobJ i intheformofasetoftasksandassociatedresources{Jobscanarriveat\ntheJobDistributerasynchronously}\n2: Output:Asetofmobileagentswitheachagentcontainingatask(s)anditsassociated\nresource(s)\n3: repeat\n4: ifAlltasksinJ i areSequentialthen\n5: ifResourcesrequiredareavailablethen\n6: ifMultipletasksrequiresamesetofresourcesthen\n7: FollowstepsasdescribedinSection5.1.C;\n8: else\n9: FollowstepsasdescribedinSection5.1.A;\n10: endif\n11: else\n12: WaitforthemobileagentstoreturnandrelinquishtheresourcesbacktotheJ Dist ;\n13: endif\n14: elseifTasksinJ i areamixofSequentialandIndependentthen\n15: ifResourcesrequiredareavailablethen\n16: ifMultipletasksrequiresamesetofresourcesthen\n17: FollowstepsasdescribedinSection5.1.C;\n18: else\n19: FollowstepsasdescribedinSection5.1.B;\n20: endif\n21: else\n22: WaitforthemobileagentstoreturnandrelinquishtheresourcesbacktotheJ Dist ;\n23: endif\n24: endif\n25: untilJobispresent\nin µ .",
      "size": 1519,
      "sentences": 3
    },
    {
      "id": 56,
      "content": ".C;\n18: else\n19: FollowstepsasdescribedinSection5.1.B;\n20: endif\n21: else\n22: WaitforthemobileagentstoreturnandrelinquishtheresourcesbacktotheJ Dist ;\n23: endif\n24: endif\n25: untilJobispresent\nin µ . Likewise, T and ψj and T and ψk are embedded within µ and µ . The SI and\n1 2 3 2 3\nnextSIwrittenontoeachoftheseagentsµ ,µ andµ are–S(cid:63) →ST2,ST2 →ST3 and\n1 2 3 1 2 2 3\nST3 → S(cid:63) respectively. Since T is the last task of the job, the next SI is stored as S(cid:63)\n3 1 3 1\nthereby freeing the robot executing this job. These 3 mobile agents are then released\nintothenetwork. B. A mix of sequential and independent tasks – Imagine a job that involves a re-\nquest for exchange of an item. The set of tasks comprising this job could be - first\nFetch (T ) the new item, then Carry (T ) it to the packing station and then Pack (T )\n1 2 3\nthe same.",
      "size": 852,
      "sentences": 8
    },
    {
      "id": 57,
      "content": "volves a re-\nquest for exchange of an item. The set of tasks comprising this job could be - first\nFetch (T ) the new item, then Carry (T ) it to the packing station and then Pack (T )\n1 2 3\nthe same. While these tasks are being executed by one robot in a sequential manner,\nanother robot could concurrently Stamp (T ) the item as defective (or some such) and\n4\nPlace (T ) it back to the concerned rack. Since the two sequences (T → T → T and\n5 1 2 3\nT → T ) are independent of each other they do not share any resources. For such\n4 5\nkind of jobs, the J sets the SI of the assigned agents µ , µ and µ to S(cid:63), ST2 and\nDist 1 2 3 1 2\nST3 and that of µ and µ to S(cid:63) and ST5, respectively. This parallel execution of the\n3 4 5 1 2\ntwosequences(T →T →T andT →T )withinajobimprovesbothtimeandrobot\n1 2 3 4 5\nutilization. C. Multiple tasks using the same resource(s) – In the above two cases, we assumed\nthatthetasksthatweresequentialdidnotuseacommonresourcei.e. (ψi∩ψj∩ψl =∅).",
      "size": 982,
      "sentences": 8
    },
    {
      "id": 58,
      "content": "ovesbothtimeandrobot\n1 2 3 4 5\nutilization. C. Multiple tasks using the same resource(s) – In the above two cases, we assumed\nthatthetasksthatweresequentialdidnotuseacommonresourcei.e. (ψi∩ψj∩ψl =∅). It may happen that a job comprises two or more tasks which require the same set of\nresources. Under such conditions, the task assignment is done purely on the basis of\n12\n=== 페이지 13 ===\nAcceptedinACMTAAS Pre-printcopy\nthe shared resource needed. For example, if ψi is required to execute tasks T and\n1\nT while ψj requires T . Thus, T and T are interdependent while T is independent\n2 3 1 2 3\n(assumingψi∩ψj =∅).Undersuchscenarios,theJ assignsboththeinterdependent\nDist\ntasksT andT toasingleagentµ whileT isassignedtoanotheragentµ .TheState\n1 2 i 3 2\nInformation(SI)embeddedwithinµ andµ aregivenbelow:\n1 2\nµ :S(cid:63) →ST2 →S(cid:63)\n1 1 2 1\nµ :S(cid:63) →S(cid:63)\n2 1 1\nIt can be seen from the above SI that µ will find a free robot and make it execute\n1\nT and T consecutively before freeing it.",
      "size": 997,
      "sentences": 7
    },
    {
      "id": 59,
      "content": "w:\n1 2\nµ :S(cid:63) →ST2 →S(cid:63)\n1 1 2 1\nµ :S(cid:63) →S(cid:63)\n2 1 1\nIt can be seen from the above SI that µ will find a free robot and make it execute\n1\nT and T consecutively before freeing it. µ will find a separate free robot and make\n1 2 2\nit execute T concurrently. Since T and T are now within the same agent, mutual\n3 1 2\nexclusionoftheresourcessharedbythesetasksareensuredbytheagentitself.Itmay\nalso happen that ψi∩ψj (cid:54)= ∅. This can be easily reduced to the scenario similar to ψi\ni.e.allthethreetasksT ,T andT willbecomeinterdependentandthus,packedinto\n1 2 3\nasingleagentbytheJ . Dist\nIt may be noted that in a set of sequential tasks within a job, say, {T ,T ,T }, the\n1 2 3\nresource for a certain task(s) (T ) could be free while those of the others are already\n3\nassignedtoagentsofthepreviousjobs.Insuchscenarios,theJ isforcedtowaitfor\nDist\nthe agents to return and relinquish the resource(s).",
      "size": 917,
      "sentences": 5
    },
    {
      "id": 60,
      "content": "n task(s) (T ) could be free while those of the others are already\n3\nassignedtoagentsofthepreviousjobs.Insuchscenarios,theJ isforcedtowaitfor\nDist\nthe agents to return and relinquish the resource(s). However, if T is an independent\n3\ntask,theJ willassignittoaseparateagentandreleaseit.Theagentthenfollows\nDist\nAlgorithm 2 and executes the assigned task. The algorithm for the J is portrayed\nDist\ninAlgorithm1. 5.2. MobileAgentbasedMechanism\nConsider a scenario with repetitive jobs with similar tasks and associated resources\nare landing on the J which are then assigned to the corresponding mobile agents\nDist\nand release into the network of robots. Now, as soon as the mobile agent µ lands on\n1\nrobot (say R ), it verifies the current state of that robot. If a matching state is found\n1\n(which in this case is S(cid:63)), µ provides the code for the task T to the robot (R here).",
      "size": 881,
      "sentences": 7
    },
    {
      "id": 61,
      "content": "t µ lands on\n1\nrobot (say R ), it verifies the current state of that robot. If a matching state is found\n1\n(which in this case is S(cid:63)), µ provides the code for the task T to the robot (R here). 1 1 1 1\nHence,therobotR commencestheexecutionoftaskT byacquiringtheresourcesψ\n1 1 1\nas per the program received from the agent µ . After the execution of task T by R ,\n1 1 1\nthemobileagentµ updatesthestateofR tothenextstate(dependinguponthenext\n1 1\ntask). Consequently, R relinquishes the resource ψ1 and waits for µ to arrive. The\n1 2\nmobileagentµ thenleavestherobot,returnsbacktoJ andreleasesthetaskalong\n1 Dist\nwith the associated resource information. This task and resource is then assigned to\na new mobile agent for the next job (which in the current scenario is similar to the\nprevious job) by the J and is then released into the network. If µ does not find a\nDist 1\nmatching state, it migrates to another neighbouring robot in a conscientious manner,\ntherebyavoidingmorerecentlyvisitedrobots.",
      "size": 1000,
      "sentences": 8
    },
    {
      "id": 62,
      "content": "the J and is then released into the network. If µ does not find a\nDist 1\nmatching state, it migrates to another neighbouring robot in a conscientious manner,\ntherebyavoidingmorerecentlyvisitedrobots. The mobile agent µ for job J lands up in another robot (say R ) in state S(cid:63) and\n1 2 2 1\nmakesitexecutetask T usingtheresource ψ1.Inthismanner, µ continuestomake\n1 1\nallrobotsinstateS(cid:63) toperformtaskT sequentially.Whenµ ,whichisalsomigrating\n1 1 2\nwithin the network, lands in R , it aids the latter in the execution of task T using\n1 2\nψ2. Hence, both the robots R and R execute the tasks T (job J ) and T (job J )\n1 2 2 1 1 2\nrespectivelyinaconcurrentmannerforminga2-stagepipeline.Astimeprogressesall\nthe k robots start executing distinct tasks concurrently to form of a k-stage pipeline.",
      "size": 802,
      "sentences": 4
    },
    {
      "id": 63,
      "content": "(job J ) and T (job J )\n1 2 2 1 1 2\nrespectivelyinaconcurrentmannerforminga2-stagepipeline.Astimeprogressesall\nthe k robots start executing distinct tasks concurrently to form of a k-stage pipeline. Here,theautonomousmobileagentsactastokenstoacquiretheassociatedresources\ninordertocarryoutanexecution.Algorithm2depictsthestepsthateachmobileagent\nfollowsfortheexecutionoftheirassignedtasks.Thus,itcanbeseenthatbyvirtueof\nfollowingthisalgorithm,thesetofagentsµordertheexecutionoftasks,inamanner\nthatensuresmutualexclusionofsharedresourcesamongthejobs.",
      "size": 549,
      "sentences": 2
    },
    {
      "id": 64,
      "content": "owsfortheexecutionoftheirassignedtasks.Thus,itcanbeseenthatbyvirtueof\nfollowingthisalgorithm,thesetofagentsµordertheexecutionoftasks,inamanner\nthatensuresmutualexclusionofsharedresourcesamongthejobs. 13\n=== 페이지 14 ===\nAcceptedinACMTAAS Pre-printcopy\nALGORITHM2: Sequenceofstepsfollowedbyeachmobileagentµ fortheexecutionoftheir\ni\nassignedtaskT\ni\n1: Input:StateS x ∈{S 1 (cid:63),S x Ti}andProgramfortaskT i ∈T;{StateisS 1 (cid:63)ifT i isthefirsttask\ntobeexecutedelseStateisSTi}\nx\n2: Output:ExecutionoftaskT i ,∀R k ∈R;\n3: repeat\n4: migrate to(R k );{AgentmigratestoarobotR k }\n5: S=get state(R k );{AgentfetchesthecurrentstateofrobotR k }\n6: ifS x ==S then\n7: commence execution(T i ,ψi);{AgentmakesrobotR k executethecodeforT i usingψ i }\n8: S x+1 =get next state();{AgentcallsthefunctiontogetthenextStateInformation\n(SI)storedwithinit}\n9: update state(R k ,S x+1 );{AgentupdatesthestateoftherobotR k tothenextstate\ncarriedbytheagent}\n10: endif\n11: leave robot(R k );{Agentmigratesintothenetworktosearchforotherrobots}\n12: untilJobispresent\nNote:AmobileagentcarrieswithittheprogramorcodeforataskT assignedtoit,thestate\ni\nS oftherobotswhichitneedstosearchforandexecutethecodeforT alongwiththevery\nx i\nnextstatetherobotshouldtransit(afterexecutionofT ),inaccordancewiththejobwhosetask\ni\nT ,itcarries.",
      "size": 1299,
      "sentences": 2
    },
    {
      "id": 65,
      "content": "signedtoit,thestate\ni\nS oftherobotswhichitneedstosearchforandexecutethecodeforT alongwiththevery\nx i\nnextstatetherobotshouldtransit(afterexecutionofT ),inaccordancewiththejobwhosetask\ni\nT ,itcarries. i\nThe proposed solution ensures that the free robots are selected and mutually ex-\ncluded once they start a task within a specific job. Thus, once a robot is booked (mu-\ntually excluded) for a job by an agent, the same robot continues to execute all tasks\nrelated to this job. The robot is finally released only after the last task (contained\nwithin the related agent) is executed. Mutual exclusion is also taken care of when\ntasks common to multiple jobs require the same resource. Common tasks requiring\ndifferent resources occurring across multiple jobs are executed concurrently. Mobile\nagents, once released into the network, act autonomously without any central con-\ntrol.",
      "size": 878,
      "sentences": 7
    },
    {
      "id": 66,
      "content": "ce. Common tasks requiring\ndifferent resources occurring across multiple jobs are executed concurrently. Mobile\nagents, once released into the network, act autonomously without any central con-\ntrol. With many networked robots in the scenario and with mobile agents knitting\nthrough this network, this proposed CPS as a whole, performs in a decentralized and\ndistributedmanner. 5.3. AsynchronousExecutionTimes\nUnlike instructions in a CPU, the tasks executed by robots may not have fixed exe-\ncution times. This could be due to a range of reasons which include wear and tear of\nvarious parts, the nature of the paths traversed by a robot, obstacles, charging times\nand network delays. This issue of non-uniformity in execution times of the various\ntasks in the pipeline cannot be efficiently handled by the traditional method of using\nacommonclock. In the present decentralized and distributed CPS, a mobile agent is the only en-\ntity that has the code for the execution of a specific task.",
      "size": 990,
      "sentences": 9
    },
    {
      "id": 67,
      "content": "handled by the traditional method of using\nacommonclock. In the present decentralized and distributed CPS, a mobile agent is the only en-\ntity that has the code for the execution of a specific task. To mitigate the problem of\nvarying time periods in the robotic pipeline, the mobile agents do not leave a robot\nuntil the concerned task is accomplished. Consider a case when R is executing task\ni\nT using µ and T takes more time than T which is being executed by R us-\nj j j j−1 i+1\ning µ . This forces R (after the execution of T ) to wait for the completion of\nj−1 i+1 j−1\nexecution of T by R . This is because µ (currently within R ) has not yet been re-\nj i j i\nleased. Thus, even though the time durations that the robots take to switch from one\ntask to another within the pipeline keep varying over time, the mobile agents facili-\ntate pipelined execution without the use of a common clock. This makes the proposed\nmechanismadaptivetovaryingtaskexecutiontimes.",
      "size": 965,
      "sentences": 8
    },
    {
      "id": 68,
      "content": "within the pipeline keep varying over time, the mobile agents facili-\ntate pipelined execution without the use of a common clock. This makes the proposed\nmechanismadaptivetovaryingtaskexecutiontimes. 14\n=== 페이지 15 ===\nAcceptedinACMTAAS Pre-printcopy\n5.4. Addition/Deletionoftask(s)on-the-fly\nAreal-worldsystemisalwayspronetochangeswhichcouldbesuddenorgradual.For\na system comprising sequential tasks, these changes can be in the form of addition of\nnew tasks or the deletion of already existing tasks to/from the set T. There may also\nbe a case where an existing task is required to be replaced by a new or modified ver-\nsion.Traditionallyinacentralizedsystem,onewouldhavetobringthewholesystem\ndownbysuspendingtheexecutionsofallthetasksandthenrestartthesameafterthe\nmodifications are made. This naturally is a time-consuming and inefficient exercise. The proposed method for the execution of sequential tasks inherently allows for On-\nThe-Fly Programming (OTFP) without bringing the system down.",
      "size": 995,
      "sentences": 6
    },
    {
      "id": 69,
      "content": "aturally is a time-consuming and inefficient exercise. The proposed method for the execution of sequential tasks inherently allows for On-\nThe-Fly Programming (OTFP) without bringing the system down. In order to ensure\nthe modification of the task sequence, all the state transitions, from one state to the\nnext, are stored a priori locally in the state transition database of each robot. In this\ncontext, modification could mean addition, deletion or altering the sequence in which\nthetasksareexecuted. The addition of a new task to the set T requires two new mobile agents — one that\nupdatesthestatechangeinformationintherobots(referredtoastheSequenceAgent\n(µ )) and another that carries the program for the new task (µ(cid:48)).",
      "size": 731,
      "sentences": 5
    },
    {
      "id": 70,
      "content": "o the set T requires two new mobile agents — one that\nupdatesthestatechangeinformationintherobots(referredtoastheSequenceAgent\n(µ )) and another that carries the program for the new task (µ(cid:48)). The former agent,\nseq 1\nµ , which is released into the network W with the new modified sequence, migrates\nseq\nwithin W and updates the state transition database within each robot to reflect the\nmodifications.Thus,iftheinitialstatetransitiondatabaseinallrobotscomprisedthe\nsequence S(cid:63), S , S ,..., S and the new task to be inserted between T and T is T(cid:48)\n1 2 3 n 1 2 1\nthen this agent updates the sequence to S(cid:63),S(cid:48),S ,S ,...,S in all robots in R. This\n1 1 2 3 n\nwould mean that a robot completing the execution of task T (in state S(cid:63)) would now\n1 1\ntransittoS(cid:48) insteadofS therebyexecutingtheassociatedtaskT(cid:48) beforeT usingthe\n1 2 1 2\nsecondnewlyreleasedagentµ(cid:48).Oncethemodificationsaredoneineachrobot,theµ\n1 seq\nterminates itself.",
      "size": 982,
      "sentences": 2
    },
    {
      "id": 71,
      "content": "ransittoS(cid:48) insteadofS therebyexecutingtheassociatedtaskT(cid:48) beforeT usingthe\n1 2 1 2\nsecondnewlyreleasedagentµ(cid:48).Oncethemodificationsaredoneineachrobot,theµ\n1 seq\nterminates itself. The second agent µ(cid:48) is the one that carries the new program as its\n1\npayloadandaidstherobotstoperformthenewtaskT(cid:48).Thisagentbehavesthesame\n1\nwayasalltheotheragentsinthesetµ. Deletion is done by merely deleting the concerned state in the transition database\nbythisagent.Itmaybenotedthatifanyofthetask(s)previoustothetaskcurrently\nbeingexecutedbytherobotgetsmodified,thentherobotcontinueswiththesuccessive\ntasks and does not redo the entire job. The sequence can also be altered in a similar\nmanner to control the order in which the tasks in T are executed. Both addition and\ndeletion,thusfacilitatetheshufflingofthesequenceoftasksinthepipelineon-the-fly. TheabovefeaturethusprovidesOTFPfacilitytothesystem. 5.5.",
      "size": 923,
      "sentences": 7
    },
    {
      "id": 72,
      "content": "order in which the tasks in T are executed. Both addition and\ndeletion,thusfacilitatetheshufflingofthesequenceoftasksinthepipelineon-the-fly. TheabovefeaturethusprovidesOTFPfacilitytothesystem. 5.5. MutualExclusionforParallelTasks\nContrary to the pipelined case, all tasks in the set T can be executed concurrently in\na fully parallel CPS. Since each task T has its own dedicated resource ψ , the agent\ni i\nµ canlatchontoanyrobotR (provideditisfree)andcommenceexecutingtheasso-\ni j\nciatedtask.Thus,iftherearentasks(i.e.nagents)andnrobotsthenatanypointof\ntime all agents can execute their respective tasks using a robot each. If there are m\njobs comprising n tasks each and if all tasks take the same amount of time t for exe-\ncution, then the total time required for execution of all the jobs would be m*t, where\n* designates the multiplication operator. Mutual exclusion will be preserved, even if\nthe number of robots is greater than the number of jobs.",
      "size": 955,
      "sentences": 8
    },
    {
      "id": 73,
      "content": "quired for execution of all the jobs would be m*t, where\n* designates the multiplication operator. Mutual exclusion will be preserved, even if\nthe number of robots is greater than the number of jobs. This is so since each task is\nassociated with a single agent which in turn can use only one robot at any moment\nof time. It may thus be noted that the mechanism described herein can cater to both\nsequentialandparallelsetsoftasks. 15\n=== 페이지 16 ===\nAcceptedinACMTAAS Pre-printcopy\n5.6. DeadlockFreedom\nAccordingtoCoffmanetal. [1971],asystemisinadeadlockstateifallthefourcondi-\ntionsdefinedbelowholdsimultaneously–\n(1) Mutual Exclusion: The resources required are non-shareable and thus requires\nmutualexclusion. (2) No-Preemption:Resourcesalreadyassignedcannotbepreempted. (3) Circularwait:Presenceofcircularlistorchainsofprocesseswaitingforresources\nacquiredbytheirpredecessors. (4) Hold and Wait: A process is holding at least one resource and is also waiting to\noccupyanotherresource.",
      "size": 986,
      "sentences": 10
    },
    {
      "id": 74,
      "content": "t:Presenceofcircularlistorchainsofprocesseswaitingforresources\nacquiredbytheirpredecessors. (4) Hold and Wait: A process is holding at least one resource and is also waiting to\noccupyanotherresource. Theconditions(1)and(2)holdforthecurrentproposedsystem.Mutualexclusionisa\nnecessaryrequirementsincetheresourcesbecomenon-shareableoncetherobotslatch\nontothem.Preemptioncomeswiththeriskofindefinitestarvationofaresource(s)by\ntherobotpreemptedbythesystemandthusaddstotheoverallcostofexecution. Considertheresource-allocationgraphshowninFigure1whichhasbeenconverted\nto a pipeline representation portrayed in Figure 2. According to condition (3), if a\nresource-allocation graph contains at least one cycle, then it can attain a deadlock\nstate.Thus,inordertoshowthattheproposedsystemisdeadlockfree,itissufficient\nto prove that the graph is acyclic. By applying Kahn [1962] algorithm for topological\nsorting on the graph shown in Figure 1, a pipeline representation similar to Figure\n2 can be obtained.",
      "size": 994,
      "sentences": 6
    },
    {
      "id": 75,
      "content": "sufficient\nto prove that the graph is acyclic. By applying Kahn [1962] algorithm for topological\nsorting on the graph shown in Figure 1, a pipeline representation similar to Figure\n2 can be obtained. This proves that the graph is a Directed Acyclic Graph (DAG). Hence,condition(3)doesnotholdfortheproposedsystemtherebymakingitdeadlock\nfree.Dependinguponthetypeofjob,condition(4)couldholdforcertainscenariosand\nthereforedoesnotguaranteethedeadlockfreebehaviouroftheproposedsystem.Even\nthough condition (3) is sufficient to ensure the deadlock free behaviour of the system,\nfurtherinvestigations toremovecondition (4)couldbe carriedoutand formsthepart\noffutureworkofthispaper. 6. IMPLEMENTATION\nIn order to validate the efficacy of the proposed mechanism, we chose an automated\nwarehouseasaCPSinordertoimplementtheproposedmechanism.ThisCPSisused\nto process shipments after the orders are received at the warehouse.",
      "size": 912,
      "sentences": 6
    },
    {
      "id": 76,
      "content": "the efficacy of the proposed mechanism, we chose an automated\nwarehouseasaCPSinordertoimplementtheproposedmechanism.ThisCPSisused\nto process shipments after the orders are received at the warehouse. The CPS within\nthe automated warehouse comprises a set of networked robots and smart racks. The\nrobots are required to fetch items from the racks and deliver them to the packaging\nzones.Thesechorescanbedecomposedintoseveraltaskssuchasfollowapathtothe\nselected rack, pick the item, traverse towards the packaging zone and place the item\nthere. This sequence of tasks involves the use of shared resources such as the racks\nand the paths. Warehouses generally optimize on space which means that the racks\nare placed close-by thus allowing only one robot to move in between them. This path\nas also the concerned rack thus form shared resources which can be used by only one\nrobot at any moment of time. This enforces the need to ensure mutual exclusion of\nresourceswithintheautomatedwarehouse.",
      "size": 988,
      "sentences": 7
    },
    {
      "id": 77,
      "content": "lso the concerned rack thus form shared resources which can be used by only one\nrobot at any moment of time. This enforces the need to ensure mutual exclusion of\nresourceswithintheautomatedwarehouse. Inordertoensurethatmutualexclusionispreserved,warehousemanagementsys-\ntems have to either constantly monitor and control the movement of robots or the\nrobots themselves have to manage and regulate such exclusions. The former method\nis more centralized and resource intensive where a single or multiple set of servers\nconstantlymonitorandcontroltherobots.Centralizedmethodshavetheirowndraw-\nbacks[Minaretal.2000].Thelattermethod,whereintherobotsthemselvesasawhole\nmanagesuchmutualexclusionsandexecutions,formsadecentralizedanddistributed\napproachwhichiswhatweportrayinthiswork.",
      "size": 776,
      "sentences": 4
    },
    {
      "id": 78,
      "content": "heirowndraw-\nbacks[Minaretal.2000].Thelattermethod,whereintherobotsthemselvesasawhole\nmanagesuchmutualexclusionsandexecutions,formsadecentralizedanddistributed\napproachwhichiswhatweportrayinthiswork. 16\n=== 페이지 17 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.3:Awarehousewithracks,robotsandembeddedboardswithsensors\nThe performance of the proposed mechanism for ordering task execution was val-\nidated by emulation followed by experiments using real robots. In order to test the\npractical viability over large networks, the proposed method was emulated on real\nnetworked nodes. Emulation (and not simulation) was carried out to ensure that the\nexperiment is closer to the real environment and captures the real-time issues such\nas network failure, congestion, packet/data loss, etc. in the system. According to the\nauthors in [Chertov et al.",
      "size": 836,
      "sentences": 6
    },
    {
      "id": 79,
      "content": "e\nexperiment is closer to the real environment and captures the real-time issues such\nas network failure, congestion, packet/data loss, etc. in the system. According to the\nauthors in [Chertov et al. 2006], emulation offers more concrete and reliable results\nthansimulation.Tartarus[Semwaletal.2015],amobileagentplatformwasusedfor\nemulation of the proposed mechanism for sequential and interdependent task execu-\ntion.Eachinstanceof Tartarusrunningonacomputeractsasa nodeinthenetwork. For the experiments, a 100-node network was created with sets of nodes running on\nseparate computers connected through a LAN.",
      "size": 610,
      "sentences": 5
    },
    {
      "id": 80,
      "content": "-\ntion.Eachinstanceof Tartarusrunningonacomputeractsasa nodeinthenetwork. For the experiments, a 100-node network was created with sets of nodes running on\nseparate computers connected through a LAN. A separate node acted as the Job Dis-\ntributor (J ) which receives the request (job) for the items and converts it in the\nDist\nformoftasksperrequest.AnotheradditionalPC(personalcomputer)wasusedtolog\nthestatusofalltheentitiesandeventsduringtheexperiments.Theselogswereused\ntoplotthegraphsandanalyzetheresults.Itmaybenotedthattheseadditionalnodes\n(J andPC)didnotparticipateintheproposedmechanism. Dist\nExperimentswereconductedtorigorouslytestthefeaturesoftheproposedmethod\nforscalability,adaptivityandOTFP.Eachexperimentwasperformed10timesandthe\naverageofthereadingswastakenintoaccountwhileplottingthegraphs∗. 7. EXPERIMENTSANDRESULTS\nIn this section, we discuss the experiments conducted and results obtained from\nboth emulation and real-robots, separately.",
      "size": 956,
      "sentences": 6
    },
    {
      "id": 81,
      "content": "eadingswastakenintoaccountwhileplottingthegraphs∗. 7. EXPERIMENTSANDRESULTS\nIn this section, we discuss the experiments conducted and results obtained from\nboth emulation and real-robots, separately. The section also compares the proposed\napproach with its centralized counterpart and highlights the conditions when it is\nfavourabletousetheformer. ∗Avideooftheexperimentperformedisavailableatthefollowinglink:\nhttp://www.iitg.ernet.in/cse/robotics/?pageid=1993\n17\n=== 페이지 18 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.4:Centralizedversustheproposeddecentralizedanddistributedapproach\n7.1. Emulation\nAsmentionedearlier,a100-nodeTartarusbasednetworkwasdeployedon10PCsover\na LAN wherein each node represented an instance of Tartarus. For honouring equal\ndistributionofload,eachPCwasinitiatedwith10instancesofTartarus.Dependingon\ntheir functionality in the real world, the nodes in the emulation scenario are divided\ninto three types.",
      "size": 927,
      "sentences": 7
    },
    {
      "id": 82,
      "content": "For honouring equal\ndistributionofload,eachPCwasinitiatedwith10instancesofTartarus.Dependingon\ntheir functionality in the real world, the nodes in the emulation scenario are divided\ninto three types. The Robotic nodes (R) and the Shared resource nodes (Φ) form the\nPrimarynodeswhiletheremainingconstitutetheSecondarynodes(Σ).Inthepresent\ncontext, these Σ nodes are the inactive nodes which merely allow the agent to flow\nthrough in the network such as router, sensor nodes, etc. They may however be made\nactive so as to perform other tasks such as sensing, data processing, etc. based on\nthe application scenario. A static agent residing on each of the R- and Φ-type nodes\nperformed the job of waiting for the mobile agents in order to receive the code for the\ntasktobeperformedwithinthem.Foremulation,thetasksweredesignedsuchthatit\nwouldtake2secondstoexecuteeachofthemassuminganidealenvironmentwithout\nany unforeseen time lags.",
      "size": 928,
      "sentences": 5
    },
    {
      "id": 83,
      "content": "der to receive the code for the\ntasktobeperformedwithinthem.Foremulation,thetasksweredesignedsuchthatit\nwouldtake2secondstoexecuteeachofthemassuminganidealenvironmentwithout\nany unforeseen time lags. Figure 3 depicts the primary and secondary nodes for a\nwarehousescenario. 7.1.1. ComparisonwithaCentrallyControlledSystem. In order to fortify our stand on the\nuse of this decentralized and distributed mechanism, it is essential to compare the\nresults of the same with those obtained using a centralized control mechanism. A\ncentralized emulation framework for the experimental set-up was thus made using\nthe same agent platform viz. Tartarus. A centralized server operating at a node was\nresponsible for posting the relevant commands using TCP-message based communi-\ncation. This centralized scenario thus comprised the central node hosting the server\nand the R and Φ nodes acting as its clients.",
      "size": 897,
      "sentences": 9
    },
    {
      "id": 84,
      "content": "le for posting the relevant commands using TCP-message based communi-\ncation. This centralized scenario thus comprised the central node hosting the server\nand the R and Φ nodes acting as its clients. The setup was obviously devoid of mobile\nagents.Theproposedmechanismforexecutionofmutually-exclusivesequentialtasks\nwasemulatedonthiscentralizedframework.Insteadofthemobileagentscarryingthe\nprograms required for the execution of the tasks, the robots herein had the required\nprogramstoexecuteallthetasks,embeddedintheirrespectivememoriesapriorion-\nboard. The experiment comprised execution of series of jobs with increasing number\n18\n=== 페이지 19 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.5:Addition/Deletionoftaskson-the-fly\nof tasks. Since the experiment was performed on an emulated framework, a total of\n5differentsoftcomputationaltaskswerechosenviz.Sorting(Sort),Merging(Merge),\nAddition (Add), Subtraction (Sub) and Division (Div) of data within the nodes.",
      "size": 958,
      "sentences": 5
    },
    {
      "id": 85,
      "content": "rformed on an emulated framework, a total of\n5differentsoftcomputationaltaskswerechosenviz.Sorting(Sort),Merging(Merge),\nAddition (Add), Subtraction (Sub) and Division (Div) of data within the nodes. The\n5 tasks were repeated for jobs containing more than 5 tasks i.e. if a job has 7 tasks,\nthanthesequentialtaskswithinthisjobcomprises–Sort,Merge,Add,Sub,Div,Sort,\nMerge. The tasks were designed in such a way that the total computational time for\neachtaskwasequalto2secondsinanidealenvironmentwithoutanylags. Initially, no resources are occupied until the execution commences. The central\nserver thus sends a message to the robot node R to commence the execution of task\n1\nT .",
      "size": 677,
      "sentences": 6
    },
    {
      "id": 86,
      "content": "idealenvironmentwithoutanylags. Initially, no resources are occupied until the execution commences. The central\nserver thus sends a message to the robot node R to commence the execution of task\n1\nT . Inorder to ensuremutual exclusion, messagesare passed tothe central server by\n1\neachrobotasandwhenataskistobeinitiatedorcompleted.Onreceivingamessage\nfrom a robot node, say R after the completion of task T (i,j ≥ 1), the centralized\nj i\nserversendsamessagetotheR nodeinformingthattheresourceψ hasbeenre-\nj+1th i\nlinquishedandthatthetaskT cannowbeexecuted.Inthiswayeachrobotexecutesa\ni\ntaskT onlywhenthecentralservergivesitagreensignaltodoso.Thecentralserver\ni\nthus manages task execution for all robot nodes and hence serves to ensure mutual\nexclusion.",
      "size": 752,
      "sentences": 4
    },
    {
      "id": 87,
      "content": "d.Inthiswayeachrobotexecutesa\ni\ntaskT onlywhenthecentralservergivesitagreensignaltodoso.Thecentralserver\ni\nthus manages task execution for all robot nodes and hence serves to ensure mutual\nexclusion. Thevariationintheperformancesofthecentralizedandtheproposedmobileagent\nbaseddecentralizedanddistributedmechanismshavebeenportrayedinFigure4.As\ncanbeobserved,whenthenumberoftasksperjobisbelow30,thecentralizedmecha-\nnismseemstoperformatadbetterthantheproposedversion.However,asthenumber\nof tasks grow (beyond 30), the throughput of the centralized system degrades rapidly\nsince the average time for execution of a task increases.",
      "size": 627,
      "sentences": 2
    },
    {
      "id": 88,
      "content": "formatadbetterthantheproposedversion.However,asthenumber\nof tasks grow (beyond 30), the throughput of the centralized system degrades rapidly\nsince the average time for execution of a task increases. With increasing number of\ntasks, the volume of information to be exchanged (between the robot nodes and the\nserver) in order to manage the execution of these tasks and ensure mutual exclusion,\nalsoincreasesdrastically.Suchalargenumberofserver-to-clientcommunicationsre-\nsultsinamajorityoftimebeingwastedonacknowledgingandreplyingtothevarious\nnodes.Whenthecentralserverisloadedwithsuchalargenumberofrequests,ittakes\nmore time for the completion of the tasks due to these computational constraints. In\nthe case of the proposed decentralized approach, the rate of increase in the average\ntimerequiredforcompletionofthejobscanbeobservedtobegradualthusindicating\nthe superiority of this approach.",
      "size": 891,
      "sentences": 3
    },
    {
      "id": 89,
      "content": "nts. In\nthe case of the proposed decentralized approach, the rate of increase in the average\ntimerequiredforcompletionofthejobscanbeobservedtobegradualthusindicating\nthe superiority of this approach. These results also show that the system is scalable\ninthesensethatitishardlyaffectedbytheincreaseinnumberoftasksperjob(aka. mobileagents). 19\n=== 페이지 20 ===\nAcceptedinACMTAAS Pre-printcopy\n7.1.2. Task Addition and Deletion. As previously mentioned, each of the tasks takes 2\nseconds to complete execution in an ideal environment. To study the effect of addi-\ntion/deletion of tasks on-the-fly, tasks were added and deleted during execution.",
      "size": 640,
      "sentences": 8
    },
    {
      "id": 90,
      "content": "tioned, each of the tasks takes 2\nseconds to complete execution in an ideal environment. To study the effect of addi-\ntion/deletion of tasks on-the-fly, tasks were added and deleted during execution. This\ncausedthelengthofthesequenceoftasksinajobtovaryatruntime.Figure5shows\nthe average time spent per task after addition or deletion of tasks in the set T. The\nnumbersaboveandbelowthecurveinthegraphdepictthenumberoftaskscomprising\nthejobbeingexecuted.AscanbeseeninFigure5,theexperimentinitiallystartedoff\nwith10tasks.Whilethesetaskswerebeingexecuted,anewtaskwasinsertedintothe\nsystem by the Job Distributor (J ).",
      "size": 613,
      "sentences": 3
    },
    {
      "id": 91,
      "content": "oftaskscomprising\nthejobbeingexecuted.AscanbeseeninFigure5,theexperimentinitiallystartedoff\nwith10tasks.Whilethesetaskswerebeingexecuted,anewtaskwasinsertedintothe\nsystem by the Job Distributor (J ). This was achieved by following the procedures\nDist\nmentioned in Section 5.4, eventually modifying the total number of tasks in the task\nsequenceto11,12,15,12,20...andsoonasdepictedinFigure5.Itmaybenotedthat\nsomeofthetaskswerealsodeletedinbetweentherun.Onecanobservethatthegraph\nis almost linear which clearly indicates that, though tasks are added/deleted through\nOTFP, there seems to be no significant impact on the net time taken for execution. This is so because the extra delays due to communication overheads and computa-\ntional requirement are distributed among the nodes of the underlying network. This\nconcurrency reduces the effective increase in such lags. In a centralized approach, all\nthese overheads would add up on the controlling entity, thereby degrading its perfor-\nmance. 7.2.",
      "size": 995,
      "sentences": 6
    },
    {
      "id": 92,
      "content": "network. This\nconcurrency reduces the effective increase in such lags. In a centralized approach, all\nthese overheads would add up on the controlling entity, thereby degrading its perfor-\nmance. 7.2. Real-RobotExperiments\nIn order to provide a proof-of-concept of the actual working of the proposed technique\nintherealworld,aprototypeofthewarehouseautomationscenariowasimplemented\nusing a set of mobile robots. The job of each mobile robot was to pick an item from a\nrack,carryittothepackagingzonesituatedatanotherlocationandplaceitthere,from\nwhereonitcouldbeparceledanddispatched.AsshowninFigure6a,theexperimental\nsetupcontainsmobilerobotsandsharedresources.Thelatterincludethesmartracks\nandthreezonesviz.alinefollowingzone,awallfollowingzoneandapackagingzone,\nall of which need to be shared i.e.",
      "size": 797,
      "sentences": 6
    },
    {
      "id": 93,
      "content": ",theexperimental\nsetupcontainsmobilerobotsandsharedresources.Thelatterincludethesmartracks\nandthreezonesviz.alinefollowingzone,awallfollowingzoneandapackagingzone,\nall of which need to be shared i.e. they need to be used by the robots in a mutually\nexclusivemanner.AjobisdividedintofoursequentialtasksdesignatedT toT ,which\n1 4\narebrieflydescribedbelow:\n(1) T :AmobilerobotwaitingattherobotbayexecutesT byvirtueofwhichitmoves\n1 1\nforward before it detects a wall. On detecting the wall, it takes a right turn and\nagainmovesforwardtofinallystopwhenitdetectsablackline. (2) T : This task makes the mobile robot to open its claws and start following the\n2\nblack line before a green marker is detected. This marker denotes the location of\nthesmartrack. (3) T : The robot picks the item from the smart rack using its claws and then follows\n3\nthe wall until a red marker is detected. It then places the item in the packaging\nzone,thusexecutingtaskT .",
      "size": 944,
      "sentences": 7
    },
    {
      "id": 94,
      "content": "ck. (3) T : The robot picks the item from the smart rack using its claws and then follows\n3\nthe wall until a red marker is detected. It then places the item in the packaging\nzone,thusexecutingtaskT . 3\n(4) T :Therobotfollowsablacklinebeforeayellowmarkerisdetectedwhichdenotes\n4\nthestartlocation,thusreenteringthebayonceagain,therebyaccomplishingtask\nT . 4\nFor experimentation with real robots, we used a set of LEGO(cid:13)R MINDSTORMS(cid:13)R\nNXT robots. Since these robots cannot host the Tartarus platform within their con-\ntrollerblock,theywereconnectedtorespectivecomputers(hostingTartarus)viaBlue-\ntooth. An interface similar to LPA-PRO-NXT interface [Jha and Nair 2012] was used\nto control the robots via these computers that formed the nodes of the network.",
      "size": 766,
      "sentences": 7
    },
    {
      "id": 95,
      "content": "ivecomputers(hostingTartarus)viaBlue-\ntooth. An interface similar to LPA-PRO-NXT interface [Jha and Nair 2012] was used\nto control the robots via these computers that formed the nodes of the network. The\nmovement of the robots was based on one castor wheel and a two-wheel differential\ndrive.Apairofclawsattachedtothefrontoftherobotsfacilitatedthepickingofitems\nwhileanon-board ultrasonic sensorgaugedthedistanceof objects infront.Therobot\n20\n=== 페이지 21 ===\nAcceptedinACMTAAS Pre-printcopy\n(a) (b)\nFig.6:(a)Topviewofthetest-bed(b)StructureofoneoftheLEGO(cid:13)R MINDSTORMS(cid:13)R\nNXTrobotusedintheexperiments\nwas capable of following a black line path using a pair of IR sensors. In addition, a\ncolour sensor detected different markers laid on the floor. Figure 6b shows the struc-\ntureofonesuchrobot.",
      "size": 804,
      "sentences": 5
    },
    {
      "id": 96,
      "content": "iments\nwas capable of following a black line path using a pair of IR sensors. In addition, a\ncolour sensor detected different markers laid on the floor. Figure 6b shows the struc-\ntureofonesuchrobot. AssoonasarequestforanitemisreceivedbytheJ ,thesameisconvertedinto\nDist\najobJ andthecorrespondingsetofmobileagentscarryingtheirrespectiveprograms\n(oneperagent)isreleasedintothenetwork.Asetoffourexperimentswereperformed\nwith the number of robots varying from 1 to 4. A total of 4 jobs were assumed to\nbe always fed into the system. In the first experiment, only one robot R was made\n1\navailable at the bay. This signifies a case when one robot needs to perform all the\ntasks in a sequential manner. R which is initially in state S(cid:63) is thus the only robot\n1 1\navailabletoreceivetheprogramfortaskT fromagentµ .Afterreceivingtheprogram,\n1 1\nR starts executing T since the shared resources viz.",
      "size": 895,
      "sentences": 8
    },
    {
      "id": 97,
      "content": "R which is initially in state S(cid:63) is thus the only robot\n1 1\navailabletoreceivetheprogramfortaskT fromagentµ .Afterreceivingtheprogram,\n1 1\nR starts executing T since the shared resources viz. all the zones and smart racks\n1 1\narefree.Asmentionedearlier,amobileagentresideswithintherobotbeforethelatter\ncompletestheassociatedtask.Afterthetaskiscompleted,themobileagentleavesthe\nrobot and starts migrating into the network in search of another robot in a similar\nstatethatrequirestheassociatedprogram. After task T is accomplished, R goes ahead in the pipeline only if the resources\n1 1\nrequired to execute T are available. This is only possible when R receives the pro-\n2 1\ngram to execute T via the corresponding agent µ . Task T is that of picking an item\n2 2 2\nfrom the rack. The third task T is to place this item at the packaging zone. After T\n3 3\nisaccomplishedR performsthefinaltaskT offollowingtheblacklineandreturning\n1 4\nto the bay from where it started.",
      "size": 970,
      "sentences": 7
    },
    {
      "id": 98,
      "content": "rom the rack. The third task T is to place this item at the packaging zone. After T\n3 3\nisaccomplishedR performsthefinaltaskT offollowingtheblacklineandreturning\n1 4\nto the bay from where it started. This experiment is one of the conventional ways of\nperforming a sequence of tasks with a single robot. It can thus be used as a baseline\nwhilecomparingtheresultsobtainedfromexperimentsusingtheproposeddecentral-\nizedanddistributedmethodusingpipelinedexecution. 21\n=== 페이지 22 ===\nAcceptedinACMTAAS Pre-printcopy\nIn the second, third and fourth set of experiments, the same jobs were executed\nbut now in a pipelined manner with the numbers of robots enumerated as 2, 3 and 4\nrespectively. Figure7depictsfourgraphs(viz.7a,7b,7cand7d).Eachgraphhereincorresponds\ntotheresultsobtainedwhenthenumberofrobotswerevariedfrom1to4respectively.",
      "size": 829,
      "sentences": 7
    },
    {
      "id": 99,
      "content": "umbers of robots enumerated as 2, 3 and 4\nrespectively. Figure7depictsfourgraphs(viz.7a,7b,7cand7d).Eachgraphhereincorresponds\ntotheresultsobtainedwhenthenumberofrobotswerevariedfrom1to4respectively. TheX-axisineachgraphrepresentsthetimeconsumed(inseconds)bythetaskswhile\ntheY-axisrepresentsthejobstobedone.Thenumbersimprintedontheboxeswithin\nthegraphsdenotetheexecutiontimestakenbythecorrespondingtasks. (a) (b)\n(c) (d)\nFig.7:(a)Executionoftasksusingasinglerobot(b),(c)and(d)Pipelinedexecutionfor\nvaryingnumberofrobotsi.e.2,3and4respectively\nFigure7ashowstheresultsobtainedwhenthereisonlyonerobotavailabletocom-\nplete the jobs. The different patterns filled inside the boxes in each row denote the\ncorresponding tasks viz. T , T , T and T . As can be seen in the Figure 7, each row\n1 2 3 4\nof boxes i.e. tasks denotes a specific job. As soon as all the tasks comprising a job are\ncompleted, the robot switches to executing the first task of the next job.",
      "size": 955,
      "sentences": 9
    },
    {
      "id": 100,
      "content": "in the Figure 7, each row\n1 2 3 4\nof boxes i.e. tasks denotes a specific job. As soon as all the tasks comprising a job are\ncompleted, the robot switches to executing the first task of the next job. In the case\nwhen there is only a single robot there are no inter-job execution delays. This is so\nbecausetherobotdoesnothavetowaitforanysharedresourcestobecomefreeforits\nuse. Figures7b,7cand7dshowresultsforcaseswhenthenumberofrobotsavailableare\n2,3and4respectively,intheexperiments.IntheFigure7b,twodistinctcolourshave\nbeen used to show the two robots — blue signifying R while green representing R . 1 2\nIt can be observed that when R is executing T ,R waits in the robot bay before the\n1 1 2\n22\n=== 페이지 23 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.8:Executionofjobscomprisingbothsequentialandindependenttasks\nresource ψ acquired by R is relinquished.",
      "size": 849,
      "sentences": 7
    },
    {
      "id": 101,
      "content": ",R waits in the robot bay before the\n1 1 2\n22\n=== 페이지 23 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.8:Executionofjobscomprisingbothsequentialandindependenttasks\nresource ψ acquired by R is relinquished. When R completes the task T , it relin-\n1 1 1 1\nquishestheassociatedresourceψ ,whichinturntriggersR tocommenceexecutionof\n1 2\nT whileR switchestoexecuteT usingresourceψ .Executioncommencesonlyafter\n1 1 2 2\nthe associated agent (µ for T and µ for T ) reach the concerned robot and provide\n1 1 2 2\ntherelevantprograms.Thus,whenthemobileagentµ triggersexecutionofT byR ,\n1 1 1\nthe rest of the robots at the bay cannot execute T since the associated mobile agent\n1\nµ isnowbusywithR .Thisinherentlyensuresproperorderingofexecutionoftasks\n1 1\nwhilealsoobeyingmutualexclusion. Subsequently, both R and R enter the pipeline and concurrently execute tasks T\n1 2 2\nand T respectively.",
      "size": 874,
      "sentences": 3
    },
    {
      "id": 102,
      "content": "hR .Thisinherentlyensuresproperorderingofexecutionoftasks\n1 1\nwhilealsoobeyingmutualexclusion. Subsequently, both R and R enter the pipeline and concurrently execute tasks T\n1 2 2\nand T respectively. It can be observed that the robots seem to take unequal times\n1\nto execute the same tasks which in turn cause idle periods between the executions of\ntwoconsecutivetasks.Eachidleperiodbetweenthetasksalongtherowindicatesthe\nextra time the robot waits for the resource of the subsequent task to be relinquished\nbyitspredecessor.Intherealworld,executiontimesdependonthewearandtearthat\nthe robots undergo, their controllers, charge on the battery and other environmental\nconditions. In Figures 7c and 7d, these idle periods are more prominent due to the\npresenceofmorerobots.Thus,onecannotprovideguaranteesthatataskwilltakethe\nsame amount of time to complete as it did earlier as in the emulation experiments.",
      "size": 904,
      "sentences": 4
    },
    {
      "id": 103,
      "content": "idle periods are more prominent due to the\npresenceofmorerobots.Thus,onecannotprovideguaranteesthatataskwilltakethe\nsame amount of time to complete as it did earlier as in the emulation experiments. The speed-up obtained when 2, 3 and 4 robots was used were found to be 1.75, 1.84\nand2.21respectively. 7.2.1. AmixofSequentialandIndependenttaskswithinajob. Real-world jobs usually com-\npriseheterogeneoustaskswhereafewofthemcouldbesequentialwhiletherestmay\nbe independent. Results for the experiments conducted for such jobs have been por-\ntrayed in Figure 8. The experiment was conducted in an emulated environment simi-\nlartotheonediscussedinSection7.1.Ascanbeseenfromthefigure,jobJ andJ are\n1 6\ncomposedofpurelysequentialtasksandthusareexecutedinsequence.JobsJ ,J ,J\n2 3 4\nand J comprises two sequences of tasks which are independent of each other. Thus,\n5\nas shown in the figure, the proposed system manages to execute the two sequences of\ntaskswithinajobinsub-optimalparallelmanner.",
      "size": 986,
      "sentences": 8
    },
    {
      "id": 104,
      "content": "ses two sequences of tasks which are independent of each other. Thus,\n5\nas shown in the figure, the proposed system manages to execute the two sequences of\ntaskswithinajobinsub-optimalparallelmanner. 23\n=== 페이지 24 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.9:Executionoftasksusing3robots-AdditionandDeletionoftaskT on-the-fly\n2A\n7.2.2. Modification of the Sequence of Tasks. Figure 9 shows the graph when a task is\nadded and deleted on-the-fly from the sequence of tasks T. In this experiment, a new\ntaskT wasintroducedviaµ duringtheexecutionofT inJob2.Itwasthendeleted\n2A 2A 2\nimmediatelyafteritsexecutioninJob2.Thesametaskwasagainaddedduringtheex-\necutionofT inJob4.Theadditionsanddeletionwereperformedusingmobileagents\n2\nasdescribedinSection5.4.Thenewtaskinthecontextofourwarehousescenariowas\nadetourfromthenormallyusedpathwhichconstitutedthemobileagentµ andthe\n2A\nassociated resource ψ . After R completed task T ,µ caused it to execute T in\n2A 2 2 2A 2A\nJob 2.",
      "size": 962,
      "sentences": 6
    },
    {
      "id": 105,
      "content": "textofourwarehousescenariowas\nadetourfromthenormallyusedpathwhichconstitutedthemobileagentµ andthe\n2A\nassociated resource ψ . After R completed task T ,µ caused it to execute T in\n2A 2 2 2A 2A\nJob 2. Since ψ is now free, R (saffron coloured row box) commenced execution of T\n2 3 2\nusingµ concurrently,asseeninFigure9.Itcanbeseenthattheintroductionoftask\n2\nT introduced a large idle period in Job 3. This was because when R was executing\n2A 3\ntaskT ,R ,havingfinishedexecutionofT ,commencedtheexecutionofT .Thecase\n2 2 2A 3\narose because the time for executing T by R was less than that for executing T\n2A 2 2\nby R . Addition and deletion of tasks on-the-fly seemed to have no effect on the other\n3\nconcurrentlyrunningtasks. 7.2.3. Removal of robots.",
      "size": 749,
      "sentences": 7
    },
    {
      "id": 106,
      "content": "executing T by R was less than that for executing T\n2A 2 2\nby R . Addition and deletion of tasks on-the-fly seemed to have no effect on the other\n3\nconcurrentlyrunningtasks. 7.2.3. Removal of robots. The batteries of all the robots needs to be recharged after\ntheirenergylevelsgobelowacertainpredefinedthreshold.Thethresholdwaschosen\nin such a way that even if this threshold were to be crossed at the commencement of\najob,therobotwouldhaveenoughenergytocompletealltheremainingtasksinthat\njob and then return to the robot bay for charging. This is synonymous to the removal\nofarobotfromthesystem.ItcanbeobservedinFigure10,thatR wasremovedafter\n2\nit completed Job 2 in a 3-robot scenario. The absence of R , caused R to perform the\n2 3\ntask T in Job 5 just after R completed T in Job 4. As can be observed the pipeline\n1 1 1\ncontinuestoexecutetasksconcurrentlyinspiteoftheabsenceofR .",
      "size": 883,
      "sentences": 8
    },
    {
      "id": 107,
      "content": "io. The absence of R , caused R to perform the\n2 3\ntask T in Job 5 just after R completed T in Job 4. As can be observed the pipeline\n1 1 1\ncontinuestoexecutetasksconcurrentlyinspiteoftheabsenceofR . 2\nItcanthusbeobservedfromtheresultsoftheexperiments,bothemulationandreal-\nworld,thatthoughthetaskexecutiontimesvary,thesystemadaptstothesechanges\nand maintains the pipeline even in the absence of a clock. Also, the resources associ-\natedtothetasksareusedinamannerthatmutualexclusionispreservedwithoutany\ndirectcommunication. 24\n=== 페이지 25 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.10:Executionoftasksusing3robots-Removalofarobot(R )on-the-fly\n2\n8.",
      "size": 645,
      "sentences": 6
    },
    {
      "id": 108,
      "content": "sareusedinamannerthatmutualexclusionispreservedwithoutany\ndirectcommunication. 24\n=== 페이지 25 ===\nAcceptedinACMTAAS Pre-printcopy\nFig.10:Executionoftasksusing3robots-Removalofarobot(R )on-the-fly\n2\n8. DISCUSSIONSANDCONCLUSIONS\nThis paper portrays a mechanism for ordering the execution of a set of interdepen-\ndenttaskswithinaCPSofrobotsandsensornodesoperatinginthereal-worldunder\ntheconstraintofmutualexclusion.TheCPS,whichformspartofanautomatedware-\nhousehasbeenusedasthetargetapplication.Thismechanism,however,canbeeasily\nported to other scenarios where shared resources are utilized and mutual exclusion\nneeds to be implemented. It has also been shown that a centralized solution could\nno doubt be an option to solving the mutual exclusion problem but its performance\ndegrades as we scale the system.",
      "size": 803,
      "sentences": 4
    },
    {
      "id": 109,
      "content": "on\nneeds to be implemented. It has also been shown that a centralized solution could\nno doubt be an option to solving the mutual exclusion problem but its performance\ndegrades as we scale the system. The use of mobile agents makes the mechanism de-\nscribed herein decentralized, distributed and scalable and also allows for changes to\nbemadeinthetasksasalsothesetofrobotsoperatingwithinthesystem,duringrun\ntimes.Themechanismcanalsocatertomorethanasinglesetofsequentialtasksex-\necuted concurrently thus forming multiple parallel pipelined sequential tasks where\ntheelementsofthepipelinecanbesharedamongotherpipelines. The proposed system is limited by the size of the network of nodes. For very large\nnetworks(nodes>1000),therecouldbeconsiderabledelayswhilesearchingforarobot\nto be serviced by a mobile agent.",
      "size": 808,
      "sentences": 5
    },
    {
      "id": 110,
      "content": "elines. The proposed system is limited by the size of the network of nodes. For very large\nnetworks(nodes>1000),therecouldbeconsiderabledelayswhilesearchingforarobot\nto be serviced by a mobile agent. The situation may worsen (delays may increase) if\nbandwidthforcommunicationisscarcelyavailable.Onesolutiontocontrolsuchalim-\nitationistousepheromone-conscientiousmigrationstrategy[GodfreyandNair2010],\nwhich allows for a bi-directional search on part of the robotic nodes and the agents\nacross the network. Tackling the complexity of the tasks whose programs are carried\nbythemobileagents,opensupfuturescopefortheresearch.Whileononesideabox-\npushingoperationmayneedjustasinglerobot,complextasks,suchascarryingalong\nobject, may require multiple robots to synchronize their operations. After reserving\ntherequirednumberofrobots,theconcernedagentwithinthisproposedsystemcould\nrelease a new set of agents or clones [Semwal et al.",
      "size": 924,
      "sentences": 6
    },
    {
      "id": 111,
      "content": "require multiple robots to synchronize their operations. After reserving\ntherequirednumberofrobots,theconcernedagentwithinthisproposedsystemcould\nrelease a new set of agents or clones [Semwal et al. 2016] capable of performing the\nconcerned tasks as also synchronizing them using stigmergy based mechanisms as\ndiscussedin[Jhaetal.2014]. The Job Distributor (J ) is the only central entity in the proposed system which\nDist\ncouldbereplacedbyitsdistributedversion.Thismeansthatinsteadofasingleentity\nthat does the task of book-keeping of the allocated resources, each node could act as\nan individual but scaled down version of the proposed J . These mini versions of\nDist\nthe J could then communicate with one another to ensure a distributed locking\nDist\nmechanism. This work can also be extended to scenarios where different robots have\ndifferent abilities such that some subset of robots can execute only certain tasks.",
      "size": 919,
      "sentences": 6
    },
    {
      "id": 112,
      "content": "nsure a distributed locking\nDist\nmechanism. This work can also be extended to scenarios where different robots have\ndifferent abilities such that some subset of robots can execute only certain tasks. The\n25\n=== 페이지 26 ===\nAcceptedinACMTAAS Pre-printcopy\nchallenge would then be to choose only those robots which are fit for execution of the\nrequired tasks. Since physical processes are performed in the real-world, the entities\nof a typical CPS are bound to encounter unpredictable changes in the environment. Further, these physical processes inherently operate at a different time-scale leading\ntothecreationofanasynchronousenvironmentwithinthesystem. Both these challenges are addressed inherently, to an extent by the mechanism de-\nscribed in this paper.",
      "size": 758,
      "sentences": 6
    },
    {
      "id": 113,
      "content": "ate at a different time-scale leading\ntothecreationofanasynchronousenvironmentwithinthesystem. Both these challenges are addressed inherently, to an extent by the mechanism de-\nscribed in this paper. A robot could fail or be removed from the CPS environment\nleadingtounpredictabilityofthenatureofexecutionofthepipeline.Unpredictablein-\ncidentssuchasthesecanconventionallycausethestallingofthepipeline.Theabsence\nof a common clock for the pipeline aids the mechanism in coping up with this situa-\ntion.Sincethemobileagentsmanagetheexecutionandmutualexclusion,thewaiting\ntimesdifferbasedontheavailabilityofthesharedresourceswhichinturnaidsinre-\nsynchronizing such unforeseen changes in the environment. This also addresses the\nchallengeposedbyfluctuationsintheexecutiontimestakenbythephysicalprocesses\nor tasks performed by the robots.",
      "size": 833,
      "sentences": 4
    },
    {
      "id": 114,
      "content": "idsinre-\nsynchronizing such unforeseen changes in the environment. This also addresses the\nchallengeposedbyfluctuationsintheexecutiontimestakenbythephysicalprocesses\nor tasks performed by the robots. Additionally, since mobile agents carry the related\nprograms for task execution, this mechanism can support heterogeneity in terms of\nthe use of a range of computational entities including robots and sensor nodes. New\nentities can be plugged into the CPS along with mobile agents carrying the programs\nfor the associated tasks. The use of mobile agents facilitates the OTFP feature which\nallowssuchinjectionoradditionanddeletionoftaskson-the-fly.Thisfeaturecanalso\nhelp in purging deprecated or faulty programs from the system and replacing them\nwiththecorrectonesduringruntime.Itisalsoenvisagedtoaugmentthismechanism\nwith Self-healing as in [Jha et al.",
      "size": 853,
      "sentences": 5
    },
    {
      "id": 115,
      "content": "urecanalso\nhelp in purging deprecated or faulty programs from the system and replacing them\nwiththecorrectonesduringruntime.Itisalsoenvisagedtoaugmentthismechanism\nwith Self-healing as in [Jha et al. 2014] so that a failure within the CPS is quickly\nnoted and the concerned agent is drawn towards the node so that the task(s) can be\nre-executed,ifrequired. ACKNOWLEDGMENTS\nTheauthorswouldliketothanktheDepartmentofScienceandTechnology,GovernmentofIndia,forthe\nfundingprovidedundertheFISTschemetosetuptheRoboticsLab.attheDepartmentofComputerScience\nand Engineering, Indian Institute of Technology Guwahati, where the entire work reported herein, was\ncarriedout. ThefirstandsecondauthorswouldalsoliketoacknowledgetheMinistryofHumanResourceDevelop-\nment,GovernmentofIndia,andTataConsultancyServices(TCS),India,forthefinancialsupportprovided\ntothemduringthecourseofthiswork.",
      "size": 870,
      "sentences": 4
    },
    {
      "id": 116,
      "content": "dsecondauthorswouldalsoliketoacknowledgetheMinistryofHumanResourceDevelop-\nment,GovernmentofIndia,andTataConsultancyServices(TCS),India,forthefinancialsupportprovided\ntothemduringthecourseofthiswork. REFERENCES\nAnchal,P.Saini,andC.R.Krishna.2014.AnEfficientPermission-Cum-ClusterBasedDistributedMutual\nExclusionAlgorithmforMobileAdhocNetworks.InProceedingsofthe2014InternationalConference\nonParallel,DistributedandGridComputing(PDGC).141–146. H.Attiya,A.Kogan,andJ.L.Welch.2010.EfficientandRobustLocalMutualExclusioninMobileAdHoc\nNetworks.IEEETransactionsonMobileComputing9,3(March2010),361–375. R.BahetiandH.Gill.2011.Cyber-physicalSystems.TheImpactofControlTechnology12(2011),161—-166. S.Basagni,M.Conti,S.Giordano,andI.Stojmenovic.2004.Mobileadhocnetworking.JohnWiley&Sons. F.Bellifemine,A.Poggi,andG.Rimassa.2001.JADE:aFIPA2000compliantagentdevelopmentenviron-\nment.InProceedingsoftheInternationalConferenceonAutonomousAgentsandMultiagentSystems. 216–217.",
      "size": 959,
      "sentences": 7
    },
    {
      "id": 117,
      "content": ".JohnWiley&Sons. F.Bellifemine,A.Poggi,andG.Rimassa.2001.JADE:aFIPA2000compliantagentdevelopmentenviron-\nment.InProceedingsoftheInternationalConferenceonAutonomousAgentsandMultiagentSystems. 216–217. S.C.BotelhoandR.Alami.1999.M+:Aschemeformulti-robotcooperationthroughnegotiatedtaskalloca-\ntionandachievement.InProceedingsoftheIEEEInternationalConferenceonRoboticsandAutomation,\nVol.2.1234–1239. A.Boukerche,R.B.Machado,K.R.L.Juca´,J.B.M.Sobral,andM.S.M.A.Notare.2007.Anagentbasedand\nbiologicalinspiredreal-timeintrusiondetectionandsecuritymodelforcomputernetworkoperations. ComputerCommunications30,13(2007),2649–2660. 26\n=== 페이지 27 ===\nAcceptedinACMTAAS Pre-printcopy\nS.BulgannawarandN.F.Vaidya.1995.AdistributedK-mutualexclusionalgorithm.InProceedingsofthe\n15thInternationalConferenceonDistributedComputingSystems.153–160. K.M.ChandyandJ.Misra.1984.TheDrinkingPhilosophersProblem.ACMTransactionsonProgramming\nLanguageandSystems6,4(Oct.1984),632–646.",
      "size": 953,
      "sentences": 8
    },
    {
      "id": 118,
      "content": "softhe\n15thInternationalConferenceonDistributedComputingSystems.153–160. K.M.ChandyandJ.Misra.1984.TheDrinkingPhilosophersProblem.ACMTransactionsonProgramming\nLanguageandSystems6,4(Oct.1984),632–646. M.Chen,S.Gonzalez,andV.C.M.Leung.2007.Applicationsanddesignissuesformobileagentsinwireless\nsensornetworks.IEEEWirelessCommunications14,December(2007),20–26. R.Chertov,S.Fahmy,andN.B.Shroff.2006.EmulationversusSimulation:AcasestudyofTCP-targeted\ndenialofserviceattacks.InProceedingsofthe2ndInternationalConferenceonTestbedsandResearch\nInfrastructuresfortheDevelopmentofNetworksandCommunities,(TRIDENTCOM’06).10pp.–325. M.M.Cruz-Cunha.2011. HandbookofResearchonMobilityandComputing:EvolvingTechnologiesand\nUbiquitousImpacts.(2Volumes).IGIGlobal,1–1584. S.S.DhenakaranandA.Parvathavarthini.2013.AnOverviewofRoutingProtocolsinMobileAd-HocNet-\nwork.InternationalJournalofAdvancedResearchinComputerScienceandSoftwareEngineering3,2\n(2013),251–259.",
      "size": 940,
      "sentences": 7
    },
    {
      "id": 119,
      "content": "l,1–1584. S.S.DhenakaranandA.Parvathavarthini.2013.AnOverviewofRoutingProtocolsinMobileAd-HocNet-\nwork.InternationalJournalofAdvancedResearchinComputerScienceandSoftwareEngineering3,2\n(2013),251–259. M.B.DiasandA.Stentz.2000.Afreemarketarchitecturefordistributedcontrolofamultirobotsystem.In\nProceedingsofthe6thInternationalConferenceonIntelligentAutonomousSystems(IAS6’11).115–122. L. D. Fife and L. Gruenwald. 2003. Research Issues for Data Communication in Mobile Ad-hoc Network\nDatabaseSystems.ACMSIGMODRecord32,2(June2003),42–47. S.FranklinandA.Graesser.1997.Isitanagent,orjustaprogram?ATaxonomyofAutonomousAgents. IntelligentAgentsIII1193(1997),21–36. B.P.GerkeyandM.J.Mataric.2001.PrincipledCommunicationforDynamicMulti-RobotTaskAllocation. LectureNotesinControlandInformationSciences271(2001),353–362.",
      "size": 809,
      "sentences": 10
    },
    {
      "id": 120,
      "content": "usAgents. IntelligentAgentsIII1193(1997),21–36. B.P.GerkeyandM.J.Mataric.2001.PrincipledCommunicationforDynamicMulti-RobotTaskAllocation. LectureNotesinControlandInformationSciences271(2001),353–362. B.P.GerkeyandM.J.Mataric.2003.Multi-robottaskallocation:Analyzingthecomplexityandoptimality\nofkeyarchitectures.InProceedingsoftheIEEEInternationalConferenceonRoboticsandAutomation,\nICRA’03,Vol.3.3862–3868. W.W.GodfreyandS.B.Nair.2008.Animmunesystembasedmulti-robotmobileagentnetwork.Lecture\nNotesinComputerScience LNCS(2008),424–433. W. W. Godfrey and S. B. Nair. 2012. A Pheromone based Mobile Agent Migration Strategy for Servicing\nNetworkedRobots.InProceedingsofthe5thInternationalICSTConferenceonBio-InspiredModelsof\nNetwork,Information,andComputingSystems,533–541. V. Hadzilacos. 2001. A Note on Group Mutual Exclusion. In Proceedings of the Twentieth Annual ACM\nSymposiumonPrinciplesofDistributedComputing(PODC’01).100–106.",
      "size": 929,
      "sentences": 13
    },
    {
      "id": 121,
      "content": "nformation,andComputingSystems,533–541. V. Hadzilacos. 2001. A Note on Group Mutual Exclusion. In Proceedings of the Twentieth Annual ACM\nSymposiumonPrinciplesofDistributedComputing(PODC’01).100–106. S.S.Jha,W.W.Godfrey,andS.B.Nair.2014.Stigmergy-BasedSynchronizationofaSequenceofTasksin\naNetworkofAsynchronousNodes.CyberneticsandSystems45,5(June2014),373–406. S.S.JhaandS.B.Nair.2012.ALogicProgrammingInterfaceforMultipleRobots.InProceedingsofthe3rd\nIEEENationalConferenceonEmergingTrendsandApplicationsinComputerScience,(NCETACS’12). 152–156. Y.Kambayashi,M.Takimoto,andY.Kodama.2005.ControllingBipedWalkingRobotsUsingGeneticAl-\ngorithms in Mobile Agent Environment. In Proceedings of the 3rd IEEE International Conference on\nComputationalCybernetics,(ICCC’05).29–34. Y.KhalufandF.Rammig.2013.TaskAllocationStrategyforTime-ConstrainedTasksinRobotsSwarms.In\nProceedingsoftheEuropeanConferenceonArtificialLife.737–744.",
      "size": 918,
      "sentences": 11
    },
    {
      "id": 122,
      "content": "rence on\nComputationalCybernetics,(ICCC’05).29–34. Y.KhalufandF.Rammig.2013.TaskAllocationStrategyforTime-ConstrainedTasksinRobotsSwarms.In\nProceedingsoftheEuropeanConferenceonArtificialLife.737–744. A.Khanna,A.K.Singh,andA.Swaroop.2015.DynamicRequestSetbasedMutualExclusionAlgorithmin\nMANETs.InternationalJournalofWirelessandMicrowaveTechnologies(IJWMT)5,4(2015),1–14. I.SuzukiandT.Kasami.1985.Adistributedmutualexclusionalgorithm.ACMTransactionsonComputer\nSystems(TOCS)3,4(1985),344–349. D.B.Lange.1998. MobileobjectsandMobileagents:Thefutureofdistributedcomputing?In Proceedings\noftheEuropeanConferenceonObject-OrientedProgramming(ECOOP’98),LectureNotesinComputer\nScience,vol1445.,1–12. P.Maes,R.H.Guttman,andA.G.Moukas.1999.AgentsThatBuyandSell.ACMCommunication42,3\n(March1999),81–91. J.MataniandS.B.Nair.2011.Typhon:AMobileAgentsFrameworkforRealWorldEmulationinProlog.In\nProceedingsofthe5thInternationalConferenceonMulti-DisciplinaryTrendsinArtificialIntelligence\n(MIWAI’11).261–273.",
      "size": 988,
      "sentences": 8
    },
    {
      "id": 123,
      "content": "J.MataniandS.B.Nair.2011.Typhon:AMobileAgentsFrameworkforRealWorldEmulationinProlog.In\nProceedingsofthe5thInternationalConferenceonMulti-DisciplinaryTrendsinArtificialIntelligence\n(MIWAI’11).261–273. E.G.Coffman,M.Elphick,andA.Shoshani.1971.SystemDeadlocks.ACMComput.Surv.3,2(June1971),\n67–78. A.B.Kahn.1962.Topologicalsortingoflargenetworks.CommunicationsoftheACM5,11(1962),558–562. 27\n=== 페이지 28 ===\nAcceptedinACMTAAS Pre-printcopy\nN. Minar, M. Gray, O. Roup, R. Krikorian, and P. Maes. 2000. Hive: Distributed agents for networking\nthings.IEEEConcurrency8(2000),24–33. S. Mostinckx, T. V. Cutsem, S. Timbermont, E. G. Boix, E´. Tanter, and W. D. Meuter. 2009. Mobile-C: A\nmobileagentplatformformobileC/C++agents.Software-PracticeandExperience39(2009),661–699. L.NullandJ.Lobur.2014. TheessentialsofComputerOrganizationandArchitecture.Jones&Bartlett\nPublishers. A.Outtagarts.2009.Mobileagent-basedapplications:Asurvey.InternationalJournalofComputerScience\nandNetworkSecurity9,11(2009),331–339.",
      "size": 995,
      "sentences": 13
    },
    {
      "id": 124,
      "content": "alsofComputerOrganizationandArchitecture.Jones&Bartlett\nPublishers. A.Outtagarts.2009.Mobileagent-basedapplications:Asurvey.InternationalJournalofComputerScience\nandNetworkSecurity9,11(2009),331–339. L.E.Parker.1998.ALLIANCE:Anarchitectureforfaulttolerantmultirobotcooperation.IEEETransac-\ntionsonRoboticsandAutomation 14,2(1998),220–240. J.L.Posadas,J.L.Poza,J.E.Simo´,G.Benet,andF.Blanes.2008.Agent-baseddistributedarchitecturefor\nmobilerobotcontrol.EngineeringApplicationsofArtificialIntelligence21,6(Sept.2008),805–823. W. W. Godfrey and S. B. Nair. 2010. A pheromone based mobile agent migration strategy for servicing\nnetworked robots. In International Conference on Bio-Inspired Models of Network, Information, and\nComputingSystems.Springer,533–541. F.L.W.RatnieksandC.Anderson.1999.Taskpartitioningininsectsocieties.InsectesSociaux46,2(1999),\n95–108. M.Raynal.1986.Algorithmsformutualexclusion.TheMITPress,Cambridge,MA(1986). T. Semwal, Nikhil S, S. S. Jha, and S. B. Nair. 2016.",
      "size": 987,
      "sentences": 12
    },
    {
      "id": 125,
      "content": "9.Taskpartitioningininsectsocieties.InsectesSociaux46,2(1999),\n95–108. M.Raynal.1986.Algorithmsformutualexclusion.TheMITPress,Cambridge,MA(1986). T. Semwal, Nikhil S, S. S. Jha, and S. B. Nair. 2016. TARTARUS: A Multi-Agent Platform for Bridging\ntheGapbetweenCyberandPhysicalSystems.InProceedingsofthe2016InternationalConferenceon\nAutonomousAgents&MultiagentSystems(AAMAS’16),1493–1495. M. Schumacher. 2001. Multi-agent systems. Objective Coordination in Multi-Agent System Engineering:\nDesignandImplementation(2001),9–32. T.Semwal,M.Bode,V.Singh,S.S.Jha,andS.B.Nair.2015.Tartarus:AMulti-agentPlatformforIntegrat-\ningCyber-PhysicalSystemsandRobots.InProceedingsofthe2015ConferenceonAdvancesInRobotics\n(AIR’15).Article20,6pages. J.Shi,J.Wan,H.Yan,andH.Suo.2011.AsurveyofCyber-PhysicalSystems.InProceedingsofthe2011\nInternationalConferenceonWirelessCommunicationsandSignalProcessing(WCSP’11).1–6. P. Tarau. 1999. Jinni: Intelligent mobile agent programming at the intersection of Java and Prolog.",
      "size": 994,
      "sentences": 14
    },
    {
      "id": 126,
      "content": "oceedingsofthe2011\nInternationalConferenceonWirelessCommunicationsandSignalProcessing(WCSP’11).1–6. P. Tarau. 1999. Jinni: Intelligent mobile agent programming at the intersection of Java and Prolog. In\nProceedingsofthe4thInternationalConferenceonThePracticalApplicationofIntelligentAgentsand\nMulti-Agents,(PAAM’99),Vol.99.109–123. W.Wu,J.Zhang,A.Luo,andJ.Cao.2015.DistributedMutualExclusionAlgorithmsforIntersectionTraffic\nControl.IEEETransactionsonParallelandDistributedSystems26,1(Jan2015),65–74. O.R.Zaiane.2002.Buildingarecommenderagentfore-learningsystems.InProceedingsoftheInternational\nConferenceonComputersinEducation.55–59. J. Gaber and M. Bakhouya. 2008. Mobile Agent-Based Approach for Resource Discovery in Peer-to-Peer\nNetworks.AgentsandPeer-to-PeerComputing.63–73. N. Minar, K. H. Kramer, and P. Maes. 1999. Cooperating Mobile Agents for Dynamic Network Routing. 287–304.",
      "size": 886,
      "sentences": 14
    },
    {
      "id": 127,
      "content": "proach for Resource Discovery in Peer-to-Peer\nNetworks.AgentsandPeer-to-PeerComputing.63–73. N. Minar, K. H. Kramer, and P. Maes. 1999. Cooperating Mobile Agents for Dynamic Network Routing. 287–304. W.W.Godfrey,S.S.Jha,andS.B.Nair.2013.OnaMobileAgentFrameworkforanInternetofThings.In\nProceedingsofthe2013InternationalConferenceonCommunicationSystemsandNetworkTechnologies. 345–350. F.SempeandA.Drogoul.2003.Adaptivepatrolforagroupofrobots.InProceedingsofthe2003IEEE/RSJ\nInternationalConferenceonIntelligentRobotsandSystems(IROS2003)(Cat.No.03CH37453),Vol.3. 2865–2869vol.3. H.N.Chu,A.Glad,O.Simonin,F.Sempe,A.Drogoul,andF.Charpillet.2007.SwarmApproachesforthe\nPatrolling Problem, Information Propagation vs. Pheromone Evaporation. In Proceedings of the 19th\nIEEEInternationalConferenceonToolswithArtificialIntelligence(ICTAI’07),Vol.1,442–449. 28",
      "size": 847,
      "sentences": 12
    }
  ]
}